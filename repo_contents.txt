
FILE TREE STRUCTURE
================================================================================
Repository structure for: C:\Users\roman\Desktop\JMU\Class stuff\Year 3\Semester 1\CS 343\Projects\local repository\personal_gh_clone
================================================================================
personal_gh_clone/
  README.md
  index.html
  lineups.html
  playerCard.html
  players.html
  report.html
  teamCard.html
  teams.html
  images/
    broncos.png
    chargers.png
    chiefs.png
    favicon.ico
    favicon.png
    faviconA.png
    fieldBackground.png
    genericLogo.jpg
    genericProfilePic.jpg
  scripts/
    main.js
    core/
      api.js
      config.js
      storage.js
      utils.js
    features/
      betting/
      fantasy/
    pages/
      dashboard.js
      lineups.js
      players.js
      teams.js
  styles/
    homepage.css
    lineups.css
    main.css
    players.css
    teams.css
  testing/
    apiTester.js
    espn-api-list.md
    output.txt
    shell_output.txt


FILE CONTENTS
================================================================================

--------------------------------------------------------------------------------
FILE: README.md
--------------------------------------------------------------------------------
[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/RvZUh8s4)

I'm testing changes
Test

--------------------------------------------------------------------------------
FILE: index.html
--------------------------------------------------------------------------------
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="NFL Fantasy Sports and Betting Analysis Dashboard">
    <title>LTR FANTASY - NFL Analysis Hub</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="stylesheet" href="styles/homepage.css">
    <link rel="icon" type="image/png" href="images/favicon.png">
</head>
<body data-page="dashboard">
    <header>
        <h1>LTR FANTASY</h1>
        <nav class="menu">
            <a href="index.html" class="current">Home</a>
            <a href="teams.html">Teams</a>
            <a href="players.html">Players</a>
            <a href="lineups.html">Lineups</a>
        </nav>
    </header>

    <main role="main" class="main-content">
        <!-- Live Games Section -->
        <section class="section live-games" aria-label="Live Games">
            <h2>Live Games</h2>
            <div id="live-games-container" class="games-grid">
                <!-- Dynamically populated by JavaScript -->
            </div>
        </section>

        <!-- Top Teams Section -->
        <section class="section top-teams" aria-label="Top Teams">
            <h2>Top Teams</h2>
            <div class="teams-grid">
                <!-- Dynamically populated by JavaScript -->
            </div>
        </section>

        <!-- Top Players Section -->
        <section class="section top-players" aria-label="Top Players">
            <h2>Top Players</h2>
            <div class="players-grid">
                <!-- Dynamically populated by JavaScript -->
            </div>
        </section>

        <!-- Fantasy Insights Section -->
        <section class="section fantasy-insights" aria-label="Fantasy Insights">
            <h2>Fantasy Insights</h2>
            <div id="insights-container" class="insights-grid">
                <!-- Dynamically populated by JavaScript -->
            </div>
        </section>

        <!-- Betting Trends Section -->
        <section class="section betting-trends" aria-label="Betting Trends">
            <h2>Betting Trends</h2>
            <div id="trends-container" class="trends-grid">
                <!-- Dynamically populated by JavaScript -->
            </div>
        </section>
    </main>

    <footer>
        <p>Data provided by ESPN API • Updated: <span id="last-updated">Loading...</span></p>
    </footer>

    <!-- Loading Overlay -->
    <div id="loading-overlay" class="loading-overlay hidden">
        <div class="loader"></div>
    </div>

    <!-- Scripts -->
    <script type="module" src="scripts/main.js"></script>
</body>
</html>

--------------------------------------------------------------------------------
FILE: lineups.html
--------------------------------------------------------------------------------
<!-- lineups.html -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LTR Fantasy - Lineups</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="stylesheet" href="styles/lineups.css">
    <link rel="icon" type="image/png" href="images/favicon.png">
</head>

<body data-page="lineups">
    <header>
        <h1>LTR FANTASY</h1>
        <nav class="menu">
            <a href="index.html">Home</a>
            <a href="teams.html">Teams</a>
            <a href="players.html">Players</a>
            <a href="lineups.html" class="current">Lineups</a>
        </nav>
    </header>

    <main class="main-content">
        <section class="lineup-builder">
            <h2>Build Your Lineup</h2>
            <div id="lineup-container">
                <!-- Lineup positions will be dynamically populated here -->
            </div>
            <form class="lineup-form">
                <input type="text" id="lineup-name" placeholder="Lineup Name" required>
                <div class="lineup-actions">
                    <button type="submit" data-action="save">Save Lineup</button>
                    <button type="button" data-action="clear">Clear Lineup</button>
                    <button type="button" data-action="export">Export Lineup</button>
                    <input type="file" data-action="import" accept=".json">
                    <button type="button" data-action="reset-all">Reset All Data</button>
                </div>
            </form>
            <div id="total-projected-points"></div>
        </section>
    </main>

    <footer>
        <p>Data provided by ESPN API • Updated: <span id="last-updated">Loading...</span></p>
    </footer>

    <div id="loading-overlay" class="loading-overlay hidden">
        <div class="loader"></div>
    </div>

    <script type="module" src="scripts/main.js"></script>
</body>

</html>

--------------------------------------------------------------------------------
FILE: playerCard.html
--------------------------------------------------------------------------------
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Team Details</title>
    <link rel="stylesheet" href="homepage.css">
</head>
<body>
  <h1>LTR FANTASY</h1>
  <div class="menu">
      <a href="index.html">Home</a>
      <a href="teams.html">Teams</a>
      <a href="players.html" class="current">Players</a>
      <a href="lineups.html">Lineups</a>
  </div>
  <main>
    <div class="main-content">
      <h2>Player Details</h2>
      <p>This is a template page for a player's detailed information. Future updates will display dynamic data for the selected player.</p>
    </div>
  </main>
</body>
</html>

--------------------------------------------------------------------------------
FILE: players.html
--------------------------------------------------------------------------------
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="NFL Players Stats and Fantasy Analysis">
    <title>LTR FANTASY - Players</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="stylesheet" href="styles/players.css">
    <link rel="icon" type="image/png" href="images/favicon.png">
</head>
<body data-page="players">
    <header>
        <h1>LTR FANTASY</h1>
        <nav class="menu">
            <a href="index.html">Home</a>
            <a href="teams.html">Teams</a>
            <a href="players.html" class="current">Players</a>
            <a href="lineups.html">Lineups</a>
        </nav>
    </header>

    <main role="main" class="main-content">
        <!-- Filters Section -->
        <section class="filters-section">
            <div class="search-container">
                <input type="text" id="player-search" placeholder="Search players..." aria-label="Search players">
            </div>
            <div class="filter-controls">
                <select id="position-filter" aria-label="Filter by position">
                    <option value="ALL">All Positions</option>
                    <option value="QB">Quarterbacks</option>
                    <option value="RB">Running Backs</option>
                    <option value="WR">Wide Receivers</option>
                    <option value="TE">Tight Ends</option>
                    <option value="K">Kickers</option>
                    <option value="DEF">Defense</option>
                </select>
                <select id="team-filter" aria-label="Filter by team">
                    <option value="ALL">All Teams</option>
                    <!-- Dynamically populated by JavaScript -->
                </select>
                <select id="sort-options" aria-label="Sort players">
                    <option value="fantasyPoints">Sort by Fantasy Points</option>
                    <option value="position">Sort by Position</option>
                    <option value="team">Sort by Team</option>
                    <option value="recentPerformance">Sort by Recent Performance</option>
                </select>
            </div>
        </section>

        <!-- Players Grid -->
        <section class="players-section">
            <div id="players-container" class="players-grid">
                <!-- Dynamically populated by JavaScript -->
            </div>
        </section>

        <!-- Fantasy Insights Section -->
        <section class="fantasy-insights-section">
            <h2>Fantasy Insights</h2>
            <div class="insights-grid">
                <div class="trend-card weekly-leaders">
                    <h3>Weekly Leaders</h3>
                    <div id="weekly-leaders-list">
                        <!-- Dynamically populated by JavaScript -->
                    </div>
                </div>
                <div class="trend-card value-picks">
                    <h3>Value Picks</h3>
                    <div id="value-picks-list">
                        <!-- Dynamically populated by JavaScript -->
                    </div>
                </div>
                <div class="trend-card injury-report">
                    <h3>Injury Report</h3>
                    <div id="injury-report-list">
                        <!-- Dynamically populated by JavaScript -->
                    </div>
                </div>
            </div>
        </section>
    </main>

    <footer>
        <p>Data provided by ESPN API • Updated: <span id="last-updated">Loading...</span></p>
    </footer>

    <!-- Loading Overlay -->
    <div id="loading-overlay" class="loading-overlay hidden">
        <div class="loader"></div>
    </div>

    <!-- Scripts -->
    <script type="module" src="scripts/main.js"></script>
</body>
</html>

--------------------------------------------------------------------------------
FILE: report.html
--------------------------------------------------------------------------------
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Report</title>
  </head>
  <body>
    <main>
        <h1>343 Project Report</h1>
        <ol>
            <li>this is the url to our github repo which is shared with each other and the prof: https://github.com/343-F24-Shrestha/343f24final-ltrfantasy</li>
            <li>our site is published</li>
            <li>our site has a page named report.html with an ordered list</li>
            <li>we have support for distinct layouts with comments in our code to show where it is</li>
            <li>we have at least five separate pages that link together, with one page being named index.html</li>
            <li>our site has multiple headers</li>
            <li>our site has navigation links that link to other pages</li>
            <li>our site have placeholder images of players and a logo all with alt attributes</li>
            <li>all pages pass the validators</li>
            <li>our site has both sans-serif and serif font</li>
            <li>our site does not yet have a form</li>
            <li>our site links to the official NFL team websites</li>
            <li>right now we are thinking that the two APIs we will use are https://www.api-football.com and https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard?dates=20221113</li>
        </ol>
    </main>
  </body>
</html>



--------------------------------------------------------------------------------
FILE: teamCard.html
--------------------------------------------------------------------------------
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Team Details</title>
    <link rel="stylesheet" href="homepage.css">
</head>
<body>
  <h1>LTR FANTASY</h1>
  <div class="menu">
      <a href="index.html">Home</a>
      <a href="teams.html" class="current">Teams</a>
      <a href="players.html">Players</a>
      <a href="lineups.html">Lineups</a>
  </div>
  <main>
    <div class="main-content">
      <h2>Team Details</h2>
      <p>This is a template page for a team's detailed information. Future updates will display dynamic data for the selected team.</p>
    </div>
  </main>
</body>
</html>

--------------------------------------------------------------------------------
FILE: teams.html
--------------------------------------------------------------------------------
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="NFL Teams Analysis and Betting Trends">
    <title>LTR FANTASY - Teams</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="stylesheet" href="styles/teams.css">
    <link rel="icon" type="image/png" href="images/favicon.png">
</head>
<body data-page="teams">
    <header>
        <h1>LTR FANTASY</h1>
        <nav class="menu">
            <a href="index.html">Home</a>
            <a href="teams.html" class="current">Teams</a>
            <a href="players.html">Players</a>
            <a href="lineups.html">Lineups</a>
        </nav>
    </header>

    <main role="main" class="main-content">
        <!-- Filters Section -->
        <section class="filters-section">
            <div class="search-container">
                <input type="text" id="team-search" placeholder="Search teams..." aria-label="Search teams">
            </div>
            <div class="filter-controls">
                <select id="conference-filter" aria-label="Filter by conference">
                    <option value="ALL">All Conferences</option>
                    <option value="AFC">AFC</option>
                    <option value="NFC">NFC</option>
                </select>
                <select id="division-filter" aria-label="Filter by division">
                    <option value="ALL">All Divisions</option>
                    <option value="North">North</option>
                    <option value="South">South</option>
                    <option value="East">East</option>
                    <option value="West">West</option>
                </select>
                <select id="sort-options" aria-label="Sort teams">
                    <option value="winPercentage">Sort by Win %</option>
                    <option value="pointsPerGame">Sort by Points/Game</option>
                    <option value="atsRecord">Sort by ATS Record</option>
                    <option value="overUnder">Sort by Over/Under</option>
                </select>
            </div>
        </section>

        <!-- Teams Grid -->
        <section class="teams-section">
            <div id="teams-container" class="teams-grid">
                <!-- Dynamically populated by JavaScript -->
            </div>
        </section>

        <!-- Betting Trends Section -->
        <section class="betting-trends-section">
            <h2>League-wide Betting Trends</h2>
            <div id="league-trends" class="trends-grid">
                <!-- Dynamically populated by JavaScript -->
            </div>
        </section>
    </main>

    <footer>
        <p>Data provided by ESPN API • Updated: <span id="last-updated">Loading...</span></p>
    </footer>

    <!-- Loading Overlay -->
    <div id="loading-overlay" class="loading-overlay hidden">
        <div class="loader"></div>
    </div>

    <!-- Scripts -->
    <script type="module" src="scripts/main.js"></script>
</body>
</html>

--------------------------------------------------------------------------------
FILE: scripts\main.js
--------------------------------------------------------------------------------
// main.js
import { showLoading, hideLoading, updateFooter } from './core/utils.js';

class App {
    constructor() {
        this.currentPage = document.body.dataset.page;
        this.activeManager = null;
    }

    async init() {
        try {
            showLoading();

            // Cleanup previous manager if it exists
            if (this.activeManager?.cleanup) {
                this.activeManager.cleanup();
            }

            // Initialize the appropriate manager based on current page
            switch (this.currentPage) {
                case 'dashboard':
                    const { default: DashboardManager } = await import('./pages/dashboard.js');
                    this.activeManager = new DashboardManager();
                    await this.activeManager.init();
                    break;

                case 'players':
                    const { default: PlayersManager } = await import('./pages/players.js');
                    this.activeManager = new PlayersManager();
                    window.playersManager = this.activeManager; 
                    await this.activeManager.init();
                    break;

                case 'teams':
                    const { default: TeamsManager } = await import('./pages/teams.js');
                    this.activeManager = new TeamsManager();
                    await this.activeManager.init();
                    break;

                case 'lineups':
                    // const { default: LineupManager } = await import('./pages/lineups.js');
                    // this.activeManager = new LineupManager();
                    // await this.activeManager.init();
                    // break;
                    const { default: LineupManager } = await import('./pages/lineups.js');
                    this.activeManager = new LineupManager();
                    window.lineupManager = this.activeManager;
                    await this.activeManager.init();
                    break;

                default:
                    console.warn('No matching page found for:', this.currentPage);
            }

            updateFooter(`${this.currentPage} page initialized successfully`);

        } catch (error) {
            console.error('Error initializing page:', error);
            updateFooter(`Error initializing page: ${error.message}`);
        } finally {
            hideLoading();
        }
    }
}

// Initialize app on page load
document.addEventListener('DOMContentLoaded', () => {
    const app = new App();
    app.init();
});

--------------------------------------------------------------------------------
FILE: scripts\core\api.js
--------------------------------------------------------------------------------
// api.js

// Import core dependencies
import CONFIG from './config.js';
import StorageManager from './storage.js';
import { validateApiResponse, formatters, DebugLogger } from './utils.js';

class NFLDataService {
    constructor() {
        this.baseUrls = {
            core: 'https://sports.core.api.espn.com/v2/sports/football/leagues/nfl',
            site: 'https://site.api.espn.com/apis/site/v2/sports/football/nfl'
        };

        this.storage = new StorageManager();

        this.rateLimit = {
            requests: 0,
            lastReset: Date.now(),
            maxRequests: 60,
            resetInterval: 30000, // 1 minute
            queueDelay: 250, // ms between requests
            backoffMultiplier: 1.5,
            maxBackoff: 10000 // 10 seconds max delay
        };

        this.cacheConfig = {
            teams: 86400,    // 24 hours
            players: 3600,   // 1 hour
            games: 300,      // 5 minutes
            stats: 1800      // 30 minutes
        };

        this.requestQueue = [];
        this.processingQueue = false;

        // Add new properties for feature management
        this.activeSubscriptions = new Map();
        this.liveGameData = new Map();
        this.lastUpdate = null;
        this.currentSeason = new Date().getFullYear();
        this.fallbackSeason = this.currentSeason - 1;

        this.initializeEventListeners();
    }

    async init() {
        await this.storage.ensureReady();
    }

    initializeEventListeners() {
        // Listen for storage quota warnings
        if (navigator.storage && navigator.storage.estimate) {
            navigator.storage.estimate().then(estimate => {
                const usageRatio = estimate.usage / estimate.quota;
                if (usageRatio > 0.8) {
                    console.warn('Storage usage high, clearing old cache...');
                    this.storage.clearExpiredCache();
                }
            });
        }
    }

    async fetchWithRetry(url, options = {}) {
        let attempts = 0;
        const maxAttempts = 3;

        while (attempts < maxAttempts) {
            try {
                const response = await this.fetchWithCache(url, options);
                return response;
            } catch (error) {
                attempts++;
                if (attempts === maxAttempts) throw error;
                await new Promise(resolve => setTimeout(resolve, 1000 * attempts));
            }
        }
    }

    // New method for managing live data subscriptions
    subscribe(eventType, callback) {
        if (!this.activeSubscriptions.has(eventType)) {
            this.activeSubscriptions.set(eventType, new Set());
        }
        this.activeSubscriptions.get(eventType).add(callback);
        return () => this.unsubscribe(eventType, callback);
    }

    unsubscribe(eventType, callback) {
        if (this.activeSubscriptions.has(eventType)) {
            this.activeSubscriptions.get(eventType).delete(callback);
        }
    }

    // New method for notifying subscribers
    notifySubscribers(eventType, data) {
        if (this.activeSubscriptions.has(eventType)) {
            this.activeSubscriptions.get(eventType).forEach(callback => {
                try {
                    callback(data);
                } catch (error) {
                    console.error(`Error in subscriber callback for ${eventType}:`, error);
                }
            });
        }
    }

    async batchCacheOperation(operations) {
        const BATCH_SIZE = 5;
        const results = [];

        for (let i = 0; i < operations.length; i += BATCH_SIZE) {
            const batch = operations.slice(i, i + BATCH_SIZE);
            const batchResults = await Promise.all(
                batch.map(op => this.storage.setCache(op.key, op.data, op.ttl))
            );
            results.push(...batchResults);
            await new Promise(resolve => setTimeout(resolve, this.rateLimit.queueDelay));
        }

        return results;
    }

    // Enhanced error handling for API calls
    async safeApiCall(url, options = {}) {
        try {
            await this.throttleRequest();
            const response = await fetch(url, options);

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();

            if (data.error) {
                throw new Error(`API error: ${data.error.message || JSON.stringify(data.error)}`);
            }

            return data;
        } catch (error) {
            console.error(`API call failed for ${url}:`, error);
            throw error;
        }
    }

    // New method for batch data fetching
    async batchFetch(urls) {
        const results = await Promise.allSettled(
            urls.map(url => this.safeApiCall(url))
        );

        return results.map((result, index) => ({
            url: urls[index],
            success: result.status === 'fulfilled',
            data: result.status === 'fulfilled' ? result.value : null,
            error: result.status === 'rejected' ? result.reason : null
        }));
    }

    // Enhanced data processing method
    processApiData(data, type) {
        if (!validateApiResponse(data, type)) {
            console.warn(`Invalid ${type} data structure received`);
            return null;
        }

        // Add data processing based on type
        switch (type) {
            case 'PLAYER':
                return this.processPlayerData(data);
            case 'TEAM':
                return this.processTeamData(data);
            case 'GAME':
                return this.processGameData(data);
            case 'ODDS':
                return this.processOddsData(data);
            default:
                return data;
        }
    }

    // async throttleRequest() {
    //     const now = Date.now();
    //     if (now - this.rateLimit.lastReset > this.rateLimit.resetInterval) {
    //         this.rateLimit.requests = 0;
    //         this.rateLimit.lastReset = now;
    //         console.log("Rate limit reset");
    //     }

    //     if (this.rateLimit.requests >= this.rateLimit.maxRequests) {
    //         const waitTime = this.rateLimit.resetInterval - (now - this.rateLimit.lastReset);
    //         console.log(`Rate limit reached, waiting ${waitTime}ms`);
    //         await new Promise(resolve => setTimeout(resolve, waitTime));
    //         return this.throttleRequest();
    //     }

    //     // Add slightly longer delay between requests to be more respectful to the API
    //     await new Promise(resolve => setTimeout(resolve, 500)); // 500ms between requests
    //     this.rateLimit.requests++;
    //     return true;
    // }

    // async throttleRequest() {
    //     const now = Date.now();
    //     if (now - this.rateLimit.lastReset > this.rateLimit.resetInterval) {
    //         this.rateLimit.requests = 0;
    //         this.rateLimit.lastReset = now;
    //         console.log("Rate limit reset");
    //     }

    //     if (this.rateLimit.requests >= this.rateLimit.maxRequests) {
    //         const waitTime = this.rateLimit.resetInterval;
    //         console.log(`Rate limit reached, waiting ${waitTime / 1000} seconds...`);
    //         await new Promise(resolve => setTimeout(resolve, waitTime));
    //         this.rateLimit.requests = 0;
    //         this.rateLimit.lastReset = Date.now();
    //         return true;
    //     }

    //     // Add longer delay between requests
    //     await new Promise(resolve => setTimeout(resolve, this.rateLimit.queueDelay));
    //     this.rateLimit.requests++;
    //     return true;
    // }

    async throttleRequest() {
        const now = Date.now();
        if (now - this.rateLimit.lastReset > this.rateLimit.resetInterval) {
            this.rateLimit.requests = 0;
            this.rateLimit.lastReset = now;
            this.rateLimit.backoffMultiplier = 1.5; // Reset backoff
            return true;
        }

        if (this.rateLimit.requests >= this.rateLimit.maxRequests) {
            const delay = Math.min(
                this.rateLimit.backoffMultiplier * this.rateLimit.queueDelay,
                this.rateLimit.maxBackoff
            );

            console.log(`Rate limit reached, waiting ${delay}ms...`);
            await new Promise(resolve => setTimeout(resolve, delay));

            // Increase backoff for next time
            this.rateLimit.backoffMultiplier *= 1.5;
            return this.throttleRequest();
        }

        await new Promise(resolve => setTimeout(resolve, this.rateLimit.queueDelay));
        this.rateLimit.requests++;
        return true;
    }

    // Functions for gathering current reference IDs for players, teams, games.

    // async getAllTeams() {
    //     const teams = await this.fetchWithCache(`${this.baseUrls.site}/teams`);
    //     return teams?.sports?.[0]?.leagues?.[0]?.teams || [];
    // }

    // Making this WAYYY more robust for no reason

    // async getAllTeams() {
    //     try {
    //         console.log('Fetching teams...');
    //         const cacheKey = 'nfl_teams';
    //         const cachedTeams = this.cache.get(cacheKey);

    //         if (cachedTeams) {
    //             console.log('Using cached teams data');
    //             return cachedTeams;
    //         }

    //         const response = await this.fetchWithCache(`${this.baseUrls.site}/teams`);
    //         console.log('Raw teams response:', response);

    //         if (!response?.sports?.[0]?.leagues?.[0]?.teams) {
    //             throw new Error('Invalid teams data structure');
    //         }

    //         const teams = response.sports[0].leagues[0].teams;
    //         console.log(`Found ${teams.length} teams`);

    //         // Cache for 24 hours
    //         this.cache.set(cacheKey, teams, 86400);

    //         return teams;
    //     } catch (error) {
    //         console.error('Error fetching teams:', error);
    //         // Return empty array instead of throwing
    //         return [];
    //     }
    // }

    async getAllTeams(forceRefresh = false) {
        const url = `${this.baseUrls.site}/teams`;

        try {
            //Debug log
            DebugLogger.log('API', 'Fetching teams data', { forceRefresh, url });

            // Check cache first unless force refresh
            if (!forceRefresh) {
                const cachedData = await this.storage.getCache(url);
                // Check if cached data exists AND contains teams
                if (cachedData?.sports?.[0]?.leagues?.[0]?.teams?.length > 0) {
                    console.log('Using cached teams data');
                    return cachedData.sports[0].leagues[0].teams;
                }
                console.log('Cached teams was empty or invalid');
            }

            console.log('Fetching fresh teams data');
            await this.throttleRequest();
            console.log('Finished waiting on throttleRequest for teams data');

            const response = await this.fetchWithCache(url, 86400);
            const data = response; // response is already parsed by fetchWithCache


            //Debug
            DebugLogger.log('API', 'Teams API response received', { status: data.status });

            //Debug
            DebugLogger.log('API', 'Teams data parsed', {
                dataStructure: data?.sports?.[0]?.leagues?.[0]?.teams ? 'valid' : 'invalid'
            });

            if (!data?.sports?.[0]?.leagues?.[0]?.teams) {
                throw new Error('Invalid teams data structure');
            }

            const teams = data.sports[0].leagues[0].teams;
            if (!teams || teams.length === 0) {
                throw new Error('No teams data received');
            }


            console.log(`Retrieved ${teams.length} teams`);
            return teams;

        } catch (error) {
            DebugLogger.log('Error', 'Teams fetch failed', error);
            console.error('Error fetching teams:', error);
            throw error;
        }
    }

    async getTeamRoster(teamId) {
        const url = `${this.baseUrls.site}/teams/${teamId}/roster?enable=roster,stats`;
        //const cacheKey = `team_roster_${teamId}`;
        try {
            // Check cache first
            const cachedRoster = await this.storage.getCache(url);
            if (cachedRoster) {
                return cachedRoster;
            }

            await this.throttleRequest();
            return await this.fetchWithCache(url, 86400);

            // if (!response.ok) {
            //     throw new Error(`HTTP error! status: ${response.status}`);
            // }

            // const data = await response.json();
            await this.storage.setCache(url, data, 86400); // Cache for 24 hours
            return data;
        } catch (error) {
            console.error(`Error fetching roster for team ${teamId}:`, error);
            return null;
        }
    }



    // async getAllActivePlayers() {
    //     try {
    //         const teams = await this.getAllTeams();
    //         if (!teams?.length) {
    //             throw new Error("No teams retrieved");
    //         }
    //         let allPlayers = [];
    //         let processedTeams = 0;
    //         let failedTeams = 0;

    //         for (const teamData of teams) {
    //             try {
    //                 // Use the correct endpoint with proper parameters
    //                 const rosterData = await this.fetchWithCache(
    //                     `${this.baseUrls.site}/teams/${teamData.team.id}/roster?enable=roster,stats`
    //                 );

    //                 if (!this.validateRosterResponse(rosterData)) {
    //                     console.warn(`Invalid roster data for team ${teamData.team.name}`);
    //                     failedTeams++;
    //                     continue;
    //                 }

    //                 if (rosterData?.athletes) {
    //                     // The roster data is organized by position groups (offense, defense, specialTeam)
    //                     const allPositionGroups = ['offense', 'defense', 'specialTeam'];

    //                     allPositionGroups.forEach(group => {
    //                         if (rosterData.athletes.find(g => g.position === group)) {
    //                             const positionGroup = rosterData.athletes.find(g => g.position === group);
    //                             const activePlayers = positionGroup.items
    //                                 .filter(player => player.status?.type === 'active')
    //                                 .map(player => ({
    //                                     id: player.id,
    //                                     fullName: player.fullName,
    //                                     position: player.position?.abbreviation,
    //                                     team: teamData.team.name,
    //                                     jersey: player.jersey,
    //                                     experience: player.experience,
    //                                     college: player.college?.name
    //                                 }));
    //                             allPlayers = [...allPlayers, ...activePlayers];
    //                         }
    //                     });
    //                 }

    //                 processedTeams++;
    //                 console.log(`Successfully processed ${teamData.team.name}: ${allPlayers.length} total active players`);
    //             } catch (error) {
    //                 failedTeams++;
    //                 console.error(`Error processing team ${teamData.team.name}:`, error.message);
    //                 continue;
    //             }
    //         }

    //         console.log(`Processed ${processedTeams} teams successfully, ${failedTeams} failed`);
    //         return allPlayers;
    //     } catch (error) {
    //         console.error("Error in getAllActivePlayers:", error);
    //         throw error; // Rethrow to ensure test catches it
    //     }
    // }

    // Modified getAllActivePlayers to fetch data in smaller batches

    // async getAllActivePlayers() {
    //     try {
    //         const teams = await this.getAllTeams();
    //         if (!teams?.length) {
    //             throw new Error("No teams retrieved");
    //         }
    //         let allPlayers = [];
    //         let processedTeams = 0;
    //         let failedTeams = 0;

    //         // Process teams in smaller batches
    //         const BATCH_SIZE = 8;
    //         for (let i = 0; i < teams.length; i += BATCH_SIZE) {
    //             const teamBatch = teams.slice(i, i + BATCH_SIZE);

    //             // Process batch sequentially
    //             for (const teamData of teamBatch) {
    //                 try {
    //                     await this.throttleRequest(); // Ensure we respect rate limits
    //                     const rosterData = await this.fetchWithCache(
    //                         `${this.baseUrls.site}/teams/${teamData.team.id}/roster?enable=roster,stats`,
    //                         3600 // Cache for 1 hour
    //                     );

    //                     if (!this.validateRosterResponse(rosterData)) {
    //                         console.warn(`Invalid roster data for team ${teamData.team.name}`);
    //                         failedTeams++;
    //                         continue;
    //                     }

    //                     if (rosterData?.athletes) {
    //                         const activePlayers = this.processRosterData(rosterData, teamData);
    //                         allPlayers = [...allPlayers, ...activePlayers];
    //                     }

    //                     processedTeams++;
    //                     console.log(`Successfully processed ${teamData.team.name}: ${allPlayers.length} total active players`);

    //                     // Add additional delay between teams
    //                     await new Promise(resolve => setTimeout(resolve, 2000));

    //                 } catch (error) {
    //                     failedTeams++;
    //                     console.error(`Error processing team ${teamData.team.name}:`, error.message);
    //                     continue;
    //                 }
    //             }

    //             // Add delay between batches
    //             if (i + BATCH_SIZE < teams.length) {
    //                 console.log(`Waiting between batches...`);
    //                 await new Promise(resolve => setTimeout(resolve, 5000));
    //             }
    //         }

    //         console.log(`Processed ${processedTeams} teams successfully, ${failedTeams} failed`);
    //         return allPlayers;
    //     } catch (error) {
    //         console.error("Error in getAllActivePlayers:", error);
    //         throw error;
    //     }
    // }

    // Sike we re doing this AGAIN

    // async getAllActivePlayers() {
    //     try {
    //         const teams = await this.getAllTeams();
    //         if (!teams?.length) {
    //             throw new Error("No teams retrieved");
    //         }
    //         let allPlayers = [];

    //         // Process only 8 teams at a time to avoid rate limits
    //         const BATCH_SIZE = 8;
    //         for (let i = 0; i < teams.length; i += BATCH_SIZE) {
    //             const teamBatch = teams.slice(i, i + BATCH_SIZE);

    //             const batchPromises = teamBatch.map(async (teamData) => {
    //                 try {
    //                     // Check cache first with a unique key
    //                     const cacheKey = `roster_${teamData.team.id}`;
    //                     const cachedRoster = this.cache.get(cacheKey);

    //                     if (cachedRoster) {
    //                         console.log(`Using cached roster for ${teamData.team.name}`);
    //                         return cachedRoster;
    //                     }

    //                     await this.throttleRequest();
    //                     const rosterData = await this.fetchWithCache(
    //                         `${this.baseUrls.site}/teams/${teamData.team.id}/roster?enable=roster,stats`
    //                     );

    //                     if (rosterData?.athletes) {
    //                         const activePlayers = this.processRosterData(rosterData, teamData);
    //                         this.cache.set(cacheKey, activePlayers, 86400); // Cache for 24 hours
    //                         return activePlayers;
    //                     }
    //                 } catch (error) {
    //                     console.warn(`Error processing team ${teamData.team.name}:`, error.message);
    //                     return [];
    //                 }
    //             });

    //             // Wait between batches
    //             const batchResults = await Promise.all(batchPromises);
    //             allPlayers = [...allPlayers, ...batchResults.flat()];

    //             if (i + BATCH_SIZE < teams.length) {
    //                 await new Promise(resolve => setTimeout(resolve, 5000));
    //             }
    //         }

    //         return allPlayers;
    //     } catch (error) {
    //         console.error("Error in getAllActivePlayers:", error);
    //         return []; // Return empty array instead of throwing
    //     }
    // }

    async getAllActivePlayers(progressCallback = null) {
        try {
            const teams = await this.getAllTeams();
            if (!teams?.length) {
                throw new Error("No teams retrieved");
            }

            let allPlayers = [];
            const BATCH_SIZE = 8;
            const totalTeams = teams.length;

            // Process teams in batches
            for (let i = 0; i < teams.length; i += BATCH_SIZE) {
                const teamBatch = teams.slice(i, i + BATCH_SIZE);
                const batchPromises = teamBatch.map(async (teamData) => {
                    try {
                        const cacheKey = `roster_${teamData.team.id}`;
                        let rosterData = await this.storage.getCache(cacheKey);

                        if (!rosterData) {
                            await this.throttleRequest();
                            const response = await fetch(
                                `${this.baseUrls.site}/teams/${teamData.team.id}/roster?enable=roster,stats`
                            );
                            rosterData = await response.json();
                            await this.storage.setCache(cacheKey, rosterData, 3600);
                        }

                        if (rosterData?.athletes) {
                            const players = this.processRosterData(rosterData, teamData);
                            return players;
                        }
                        return [];
                    } catch (error) {
                        console.warn(`Error processing team ${teamData.team.name}:`, error.message);
                        return [];
                    }
                });

                const batchResults = await Promise.all(batchPromises);
                const batchPlayers = batchResults.flat();
                allPlayers = [...allPlayers, ...batchPlayers];

                // Report progress
                if (progressCallback) {
                    const progress = Math.round((i + BATCH_SIZE) / totalTeams * 100);
                    progressCallback(progress, allPlayers.length);
                }

                // Store batch in IndexedDB
                await this.storage.setPlayers(batchPlayers, true);

                // Small delay between batches
                if (i + BATCH_SIZE < teams.length) {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }

            return allPlayers;
        } catch (error) {
            console.error("Error in getAllActivePlayers:", error);
            return [];
        }
    }

    // Helper method to process roster data
    processRosterData(rosterData, teamData) {
        const allPositionGroups = ['offense', 'defense', 'specialTeam'];
        let players = [];

        allPositionGroups.forEach(group => {
            const positionGroup = rosterData.athletes.find(g => g.position === group);
            if (positionGroup) {
                const activePlayers = positionGroup.items
                    .filter(player => player.status?.type === 'active')
                    .map(player => ({
                        id: player.id,
                        fullName: player.fullName,
                        position: player.position?.abbreviation,
                        team: teamData.team.name,
                        jersey: player.jersey,
                        experience: player.experience,
                        college: player.college?.name
                    }));
                players = [...players, ...activePlayers];
            }
        });

        return players;
    }

    async getCurrentWeekGames() {
        try {
            const cacheKey = 'current_week_games';
            const cachedGames = await this.storage.getCache(cacheKey);
            if (cachedGames) {
                return cachedGames;
            }

            const games = await this.fetchWithCache(`${this.baseUrls.site}/scoreboard`);
            const processedGames = games?.events || [];

            await this.storage.setCache(cacheKey, processedGames, 300); // Cache for 5 minutes
            return processedGames;
        } catch (error) {
            console.error("Error fetching current week games:", error);
            return [];
        }
    }

    // Validation Functions

    validateResponse(data, type) {
        if (!validateApiResponse(data, type)) {
            console.warn(`Invalid ${type} data structure received:`, data);
            return false;
        }
        return true;
    }

    validateRosterResponse(data) {
        if (!data || !data.athletes || !Array.isArray(data.athletes)) {
            console.error("Invalid roster data structure:", data);
            return false;
        }
        return true;
    }

    async validateTeamId(teamId) {
        const teams = await this.getAllTeams();
        return teams.some(team => team.team.id === teamId);
    }

    async validatePlayerId(playerId) {
        const players = await this.getAllActivePlayers();
        return players.some(player => player.id === playerId);
    }

    validatePlayerData(data) {
        const required = ['id', 'fullName', 'position'];
        return required.every(field => data?.[field]);
    }

    async validateGameId(gameId) {
        const games = await this.getCurrentWeekGames();
        return games.some(game => game.id === gameId);
    }

    // Fantasy-relevant player stats
    async getPlayerFantasyStats(playerId) {
        const cacheKey = `player_fantasy_stats_${playerId}`;
        try {
            const cachedStats = await this.storage.getCache(cacheKey);
            if (cachedStats) {
                return cachedStats;
            }

            const stats = await this.fetchWithCache(
                `${this.baseUrls.core}/seasons/2024/types/2/athletes/${playerId}/statistics`,
                3600 // 1 hour cache
            );

            const fantasyStats = {
                passing: {
                    yards: this.extractStat(stats, 'passing', 'passingYards'),
                    touchdowns: this.extractStat(stats, 'passing', 'passingTouchdowns'),
                    interceptions: this.extractStat(stats, 'passing', 'interceptions')
                },
                rushing: {
                    yards: this.extractStat(stats, 'rushing', 'rushingYards'),
                    touchdowns: this.extractStat(stats, 'rushing', 'rushingTouchdowns')
                },
                receiving: {
                    yards: this.extractStat(stats, 'receiving', 'receivingYards'),
                    touchdowns: this.extractStat(stats, 'receiving', 'receivingTouchdowns'),
                    receptions: this.extractStat(stats, 'receiving', 'receptions')
                }
            };

            await this.storage.setCache(cacheKey, fantasyStats, 3600);
            return fantasyStats;

        } catch (error) {
            console.error(`Failed to load fantasy stats for player ${playerId}:`, error);
            return null;
        }
    }

    // Betting-relevant team stats
    async getTeamBettingStats(teamId) {
        const cacheKey = `team_betting_stats_${teamId}`;
        try {
            const cachedStats = await this.storage.getCache(cacheKey);
            if (cachedStats) {
                return cachedStats;
            }

            const stats = await this.fetchWithCache(
                `${this.baseUrls.core}/seasons/2024/types/2/teams/${teamId}/statistics`,
                3600 // 1 hour cache
            );

            const bettingStats = {
                offense: {
                    pointsPerGame: this.extractStat(stats, 'scoring', 'totalPointsPerGame'),
                    totalYards: this.extractStat(stats, 'general', 'totalYards'),
                    passingYards: this.extractStat(stats, 'passing', 'netPassingYards'),
                    rushingYards: this.extractStat(stats, 'rushing', 'rushingYards')
                },
                defense: {
                    pointsAllowed: this.extractStat(stats, 'defensive', 'pointsAllowed'),
                    sacks: this.extractStat(stats, 'defensive', 'sacks'),
                    interceptions: this.extractStat(stats, 'defensiveInterceptions', 'interceptions')
                },
                trends: {
                    homeRecord: this.extractStat(stats, 'miscellaneous', 'homeRecord'),
                    awayRecord: this.extractStat(stats, 'miscellaneous', 'awayRecord'),
                    lastFiveGames: this.extractStat(stats, 'miscellaneous', 'lastFiveGames')
                }
            };

            await this.storage.setCache(cacheKey, bettingStats, 3600);
            return bettingStats;

        } catch (error) {
            console.error(`Failed to load betting stats for team ${teamId}:`, error);
            return null;
        }
    }

    // Live game data for real-time betting
    async getLiveGameData() {
        try {
            const scoreboard = await this.fetchWithCache(
                `${this.baseUrls.site}/scoreboard`,
                300 // 5 minute cache
            );

            if (!scoreboard?.events) {
                console.warn('Invalid scoreboard data received');
                return null;
            }

            return scoreboard;
        } catch (error) {
            console.error("Error fetching live game data:", error);
            return null;
        }
    }

    // UTILITY FUNCTIONS

    async fetchWithCache(url, expireSeconds = null, retries = 3) {
        // Set cache times based on content type
        if (expireSeconds === null) {
            if (url.includes('roster')) {
                expireSeconds = 86400; // 24 hours for roster data
            } else if (url.includes('statistics')) {
                expireSeconds = 3600; // 1 hour for stats
            } else if (url.includes('odds') || url.includes('scores')) {
                expireSeconds = 300; // 5 minutes for live data
            } else {
                expireSeconds = 3600; // Default 1 hour
            }
        }

        // Check cache first
        try {
            const cachedData = await this.storage.getCache(url);
            if (cachedData) {
                console.log(`Cache hit for ${url}`);
                return cachedData;
            }
            console.log(`Cache miss for ${url}`);
        } catch (error) {
            console.warn(`Cache read error for ${url}:`, error);
        }

        // Retry loop
        for (let i = 0; i < retries; i++) {
            try {
                await this.throttleRequest(); // Rate limiting

                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} for ${url}`);
                }

                const data = await response.json();
                if (!data) {
                    throw new Error(`No data received from ${url}`);
                }

                if (data.error) {
                    throw new Error(`ESPN API error: ${data.error.message || JSON.stringify(data.error)}`);
                }

                // Store in cache
                try {
                    await this.storage.setCache(url, data, expireSeconds);
                    console.log(`Cached data for ${url} (expires in ${expireSeconds}s)`);
                } catch (cacheError) {
                    console.warn(`Cache write error for ${url}:`, cacheError);
                    // Continue even if caching fails
                }

                return data;

            } catch (error) {
                console.error(`Attempt ${i + 1}/${retries} failed for ${url}:`, error.message);

                if (i === retries - 1) {
                    throw error; // Throw on final retry
                }

                // Exponential backoff
                const waitTime = Math.pow(2, i) * 1000;
                console.log(`Waiting ${waitTime}ms before retry...`);
                await new Promise(resolve => setTimeout(resolve, waitTime));
            }
        }
    }

    extractStat(stats, category, statName, perGame = false) {
        try {
            if (!stats?.splits?.categories) {
                return {
                    value: null,
                    displayValue: "N/A",
                    rank: null
                };
            }
            const categoryStats = stats.splits.categories.find(c => c.name === category);
            if (!categoryStats?.stats) return null;

            const stat = categoryStats.stats.find(s => s.name === statName);
            if (!stat) return null;

            return {
                value: perGame ? stat.value / stats.gamesPlayed : stat.value,
                displayValue: stat.displayValue || String(stat.value),
                rank: stat.rank || null
            };
        } catch (e) {
            console.warn(`Failed to extract ${category}.${statName}:`, e);
            return null;
        }
    }

    extractTeamGameStats(team) {
        return {
            totalYards: team.statistics.find(s => s.name === 'totalYards')?.value,
            passingYards: team.statistics.find(s => s.name === 'netPassingYards')?.value,
            rushingYards: team.statistics.find(s => s.name === 'rushingYards')?.value,
            turnovers: team.statistics.find(s => s.name === 'turnovers')?.value,
            timeOfPossession: team.statistics.find(s => s.name === 'possessionTime')?.value
        };
    }

    extractSpread(event) {
        try {
            const odds = event.competitions[0].odds[0];
            return {
                favorite: odds.details.split(' ')[0],
                line: parseFloat(odds.details.split(' ')[1])
            };
        } catch (e) {
            return null;
        }
    }

    extractOverUnder(event) {
        try {
            return parseFloat(event.competitions[0].odds[0].overUnder);
        } catch (e) {
            return null;
        }
    }

    extractLastNGames(stats, n) {
        try {
            return stats.splits.find(s => s.type === 'lastNGames' && s.value === n)?.stats || null;
        } catch (e) {
            return null;
        }
    }

    // GAME DATA FUNCTIONS

    async getUpcomingGames() {
        try {
            const scoreboard = await this.fetchWithCache(
                `${this.baseUrls.site}/scoreboard`,
                300 // 5 minute cache
            );

            return scoreboard.events.map(event => ({
                id: event.id,
                homeTeam: {
                    id: event.competitions[0].competitors[0].id,
                    name: event.competitions[0].competitors[0].team.name,
                    score: event.competitions[0].competitors[0].score,
                    logo: event.competitions[0].competitors[0].team.logo
                },
                awayTeam: {
                    id: event.competitions[0].competitors[1].id,
                    name: event.competitions[0].competitors[1].team.name,
                    score: event.competitions[0].competitors[1].score,
                    logo: event.competitions[0].competitors[1].team.logo
                },
                startTime: event.date,
                spread: this.extractSpread(event),
                overUnder: this.extractOverUnder(event),
                status: event.status.type.detail
            }));
        } catch (error) {
            console.error("Error fetching upcoming games:", error);
            return [];
        }
    }

    async getGameDetails(gameId) {
        if (!gameId || gameId === 'invalid_game') {
            throw new Error('Invalid game ID provided');
        }

        try {
            const cacheKey = `game_details_${gameId}`;
            const cachedDetails = await this.storage.getCache(cacheKey);
            if (cachedDetails) {
                return cachedDetails;
            }

            const game = await this.fetchWithCache(
                `${this.baseUrls.site}/summary?event=${gameId}`,
                300 // 5 minute cache for game details
            );

            if (!game) {
                throw new Error('No game data found');
            }

            const gameDetails = {
                gameInfo: {
                    startTime: game?.header?.timeValid || null,
                    venue: game?.gameInfo?.venue?.fullName || null,
                    attendance: game?.gameInfo?.attendance || 0,
                    weather: game?.gameInfo?.weather || null
                },
                teamStats: {
                    home: game?.boxscore?.teams?.[0] ?
                        this.extractTeamGameStats(game.boxscore.teams[0]) : null,
                    away: game?.boxscore?.teams?.[1] ?
                        this.extractTeamGameStats(game.boxscore.teams[1]) : null
                },
                situation: game?.situation ? {
                    possession: game.situation.possession,
                    down: game.situation.down,
                    distance: game.situation.distance,
                    yardLine: game.situation.yardLine,
                    lastPlay: game.situation.lastPlay?.text
                } : null,
                score: {
                    home: game?.header?.competitions?.[0]?.competitors?.[0]?.score || '0',
                    away: game?.header?.competitions?.[0]?.competitors?.[1]?.score || '0'
                }
            };

            await this.storage.setCache(cacheKey, gameDetails, 300);
            return gameDetails;

        } catch (error) {
            console.error("Error fetching game details:", error);
            throw error;
        }
    }

    // BETTING DATA FUNCTIONS

    async getBettingData(gameId) {
        if (!gameId) throw new Error('Game ID is required');

        const cacheKey = `betting_data_${gameId}`;
        try {
            const cachedData = await this.storage.getCache(cacheKey);
            if (cachedData) {
                return cachedData;
            }

            const odds = await this.fetchWithCache(
                `${this.baseUrls.core}/events/${gameId}/competitions/${gameId}/odds`,
                300 // 5 minute cache for betting data
            );

            if (!odds || !odds[0]) {
                return this.getEmptyBettingData();
            }

            const currentOdds = odds[0];
            if (!this.validateResponse(currentOdds, 'ODDS')) {
                console.warn('Invalid odds data structure received');
                return this.getEmptyBettingData();
            }

            const bettingData = {
                spread: currentOdds.spread ? {
                    favorite: currentOdds.spread.favorite?.abbreviation || null,
                    line: currentOdds.spread.line || null,
                    odds: currentOdds.spread.odds || null
                } : null,
                moneyline: {
                    home: currentOdds.moneyline?.home || null,
                    away: currentOdds.moneyline?.away || null
                },
                overUnder: {
                    total: currentOdds.overUnder || null,
                    overOdds: currentOdds.overOdds || null,
                    underOdds: currentOdds.underOdds || null
                },
                movements: currentOdds.movements?.map(m => ({
                    time: m.timestamp,
                    type: m.type,
                    from: m.from,
                    to: m.to
                })) || []
            };

            await this.storage.setCache(cacheKey, bettingData, 300);
            return bettingData;

        } catch (error) {
            console.error("Error fetching betting data:", error);
            return this.getEmptyBettingData();
        }
    }

    getEmptyBettingData() {
        return {
            spread: null,
            moneyline: null,
            overUnder: null,
            movements: []
        };
    }

    async getTeamTrends(teamId) {
        const stats = await this.fetchWithCache(
            `${this.baseUrls.core}/seasons/2024/types/2/teams/${teamId}/statistics`
        );

        return {
            overall: {
                wins: this.extractStat(stats, 'record', 'wins'),
                losses: this.extractStat(stats, 'record', 'losses'),
                pointsPerGame: this.extractStat(stats, 'scoring', 'totalPointsPerGame'),
                pointsAllowedPerGame: this.extractStat(stats, 'defensive', 'pointsAllowedPerGame')
            },
            ats: {
                record: this.extractStat(stats, 'betting', 'atsRecord'),
                homeRecord: this.extractStat(stats, 'betting', 'homeAtsRecord'),
                awayRecord: this.extractStat(stats, 'betting', 'awayAtsRecord')
            },
            overUnder: {
                overs: this.extractStat(stats, 'betting', 'oversRecord'),
                unders: this.extractStat(stats, 'betting', 'undersRecord'),
                pushes: this.extractStat(stats, 'betting', 'pushesRecord')
            },
            situational: {
                homeStraightUp: this.extractStat(stats, 'record', 'homeRecord'),
                awayStraightUp: this.extractStat(stats, 'record', 'awayRecord'),
                asFavorite: this.extractStat(stats, 'record', 'favoriteRecord'),
                asUnderdog: this.extractStat(stats, 'record', 'underdogRecord')
            }
        };
    }

    // FANTASY DATA FUNCTIONS

    async getPlayerProjections(playerId) {
        const cacheKey = `player_projections_${playerId}`;
        try {
            const cachedProjections = await this.storage.getCache(cacheKey);
            if (cachedProjections) {
                return cachedProjections;
            }

            // Use historical data for projections
            const stats = await this.getSeasonData(
                `${this.baseUrls.core}/athletes/${playerId}/projections`,
                'types/2',
                false
            );

            const projections = {
                passing: {
                    attempts: this.extractStat(stats, 'passing', 'passingAttempts'),
                    completions: this.extractStat(stats, 'passing', 'completions'),
                    yards: this.extractStat(stats, 'passing', 'passingYards'),
                    touchdowns: this.extractStat(stats, 'passing', 'passingTouchdowns'),
                    interceptions: this.extractStat(stats, 'passing', 'interceptions')
                },
                rushing: {
                    attempts: this.extractStat(stats, 'rushing', 'rushingAttempts'),
                    yards: this.extractStat(stats, 'rushing', 'rushingYards'),
                    touchdowns: this.extractStat(stats, 'rushing', 'rushingTouchdowns')
                },
                receiving: {
                    targets: this.extractStat(stats, 'receiving', 'receivingTargets'),
                    receptions: this.extractStat(stats, 'receiving', 'receptions'),
                    yards: this.extractStat(stats, 'receiving', 'receivingYards'),
                    touchdowns: this.extractStat(stats, 'receiving', 'receivingTouchdowns')
                }
            };

            await this.storage.setCache(cacheKey, projections, 7200); // 2 hour cache for projections
            return projections;

        } catch (error) {
            console.error(`Failed to load projections for player ${playerId}:`, error);
            return null;
        }
    }

    async getPlayerMatchupStats(playerId, opponentId) {
        const cacheKey = `player_matchup_${playerId}_${opponentId}`;
        try {
            const cachedMatchup = await this.storage.getCache(cacheKey);
            if (cachedMatchup) {
                return cachedMatchup;
            }

            const [playerStats, opponentStats] = await Promise.all([
                this.getPlayerStats(playerId),
                this.getTeamDefensiveStats(opponentId)
            ]);

            const matchupStats = {
                player: {
                    seasonAverages: {
                        passingYards: this.extractStat(playerStats, 'passing', 'passingYardsPerGame'),
                        rushingYards: this.extractStat(playerStats, 'rushing', 'rushingYardsPerGame'),
                        receivingYards: this.extractStat(playerStats, 'receiving', 'receivingYardsPerGame')
                    },
                    recentForm: this.extractLastNGames(playerStats, 3)
                },
                opponent: {
                    vsPosition: {
                        passingYardsAllowed: this.extractStat(opponentStats, 'defensive', 'passingYardsAllowedPerGame'),
                        rushingYardsAllowed: this.extractStat(opponentStats, 'defensive', 'rushingYardsAllowedPerGame'),
                        receivingYardsAllowed: this.extractStat(opponentStats, 'defensive', 'receivingYardsAllowedPerGame')
                    },
                    recentDefense: this.extractLastNGames(opponentStats, 3)
                }
            };

            await this.storage.setCache(cacheKey, matchupStats, 3600); // 1 hour cache
            return matchupStats;

        } catch (error) {
            console.error(`Failed to load matchup stats for player ${playerId} vs ${opponentId}:`, error);
            return null;
        }
    }

    async getSeasonData(endpoint, params, requireCurrent = false) {
        try {
            const currentYear = '2024';
            const fallbackYear = '2023';

            // Try current season first
            const currentData = await this.fetchWithCache(
                `${endpoint}/${currentYear}/${params}`,
                3600
            );
            if (currentData) return currentData;

            // If current season fails and we don't require current data
            if (!requireCurrent) {
                console.log(`Falling back to ${fallbackYear} data`);
                return await this.fetchWithCache(
                    `${endpoint}/${fallbackYear}/${params}`,
                    3600
                );
            }
            return null;
        } catch (error) {
            console.warn('Season data fetch failed:', error);
            return null;
        }
    }

    async getPlayerStats(playerId) {
        // Use current season for live stats
        const stats = await this.getSeasonData(
            `${this.baseUrls.core}/athletes/${playerId}/statistics`,
            'types/2',
            true
        );
        return stats;
    }

    // For moneyline/spread predictions
    async getTeamPerformanceMetrics(teamId) {
        const cacheKey = `team_performance_${teamId}`;
        try {
            const cachedMetrics = await this.storage.getCache(cacheKey);
            if (cachedMetrics) {
                return cachedMetrics;
            }

            const stats = await this.fetchWithCache(
                `${this.baseUrls.core}/seasons/2024/types/2/teams/${teamId}/statistics`,
                3600
            );

            const metrics = {
                offense: {
                    pointsPerGame: this.extractStat(stats, 'scoring', 'totalPointsPerGame'),
                    yardsPerGame: this.extractStat(stats, 'passing', 'yardsPerGame'),
                    thirdDownConvPct: this.extractStat(stats, 'miscellaneous', 'thirdDownConvPct'),
                    redZoneEfficiency: this.extractStat(stats, 'miscellaneous', 'redzoneScoringPct')
                },
                defense: {
                    pointsAllowedPerGame: this.extractStat(stats, 'defensive', 'pointsAllowed'),
                    yardsAllowedPerGame: this.extractStat(stats, 'defensive', 'yardsAllowed'),
                    sacks: this.extractStat(stats, 'defensive', 'sacks'),
                    takeaways: this.extractStat(stats, 'miscellaneous', 'totalTakeaways')
                }
            };

            await this.storage.setCache(cacheKey, metrics, 3600);
            return metrics;

        } catch (error) {
            console.error(`Failed to load performance metrics for team ${teamId}:`, error);
            return null;
        }
    }

    // For player props
    async getPlayerPropMetrics(playerId) {
        const stats = await this.fetchWithCache(
            `${this.baseUrls.core}/seasons/2024/types/2/athletes/${playerId}/statistics`
        );

        return {
            passing: {
                yardsPerGame: this.extractStat(stats, 'passing', 'passingYardsPerGame'),
                completionPct: this.extractStat(stats, 'passing', 'completionPct'),
                attemptsPerGame: this.extractStat(stats, 'passing', 'passingAttempts', true),
                yardsPerAttempt: this.extractStat(stats, 'passing', 'yardsPerPassAttempt')
            },
            rushing: {
                yardsPerGame: this.extractStat(stats, 'rushing', 'rushingYardsPerGame'),
                attemptsPerGame: this.extractStat(stats, 'rushing', 'rushingAttempts', true),
                yardsPerCarry: this.extractStat(stats, 'rushing', 'yardsPerRushAttempt')
            },
            receiving: {
                yardsPerGame: this.extractStat(stats, 'receiving', 'receivingYardsPerGame'),
                receptionsPerGame: this.extractStat(stats, 'receiving', 'receptions', true),
                yardsPerReception: this.extractStat(stats, 'receiving', 'yardsPerReception'),
                targetShare: this.extractStat(stats, 'receiving', 'receivingTargets', true)
            }
        };
    }

    // For over/under predictions
    async getGameScoringFactors(homeTeamId, awayTeamId) {
        const [homeStats, awayStats] = await Promise.all([
            this.getTeamPerformanceMetrics(homeTeamId),
            this.getTeamPerformanceMetrics(awayTeamId)
        ]);

        return {
            homeTeam: {
                averagePointsFor: homeStats.offense.pointsPerGame,
                averagePointsAgainst: homeStats.defense.pointsAllowedPerGame,
                offensiveEfficiency: homeStats.offense.redZoneEfficiency,
                defensiveEfficiency: homeStats.defense.takeaways
            },
            awayTeam: {
                averagePointsFor: awayStats.offense.pointsPerGame,
                averagePointsAgainst: awayStats.defense.pointsAllowedPerGame,
                offensiveEfficiency: awayStats.offense.redZoneEfficiency,
                defensiveEfficiency: awayStats.defense.takeaways
            }
        };
    }

    // For live betting updates
    async getLiveGameStats(gameId) {
        const game = await this.fetchWithCache(
            `${this.baseUrls.site}/scoreboard/events/${gameId}`,
            30 // shorter cache time for live data
        );

        return {
            score: {
                home: game.homeTeam.score,
                away: game.awayTeam.score
            },
            timeRemaining: game.status.displayClock,
            quarter: game.status.period,
            possession: game.situation.possession,
            lastPlay: game.situation.lastPlay,
            momentum: {
                yardsLastDrive: game.drives.current.yards,
                timeOfPossession: game.drives.current.timeOfPossession
            }
        };
    }

    // FANTASY LINEUP OPTIMIZATION METHODS

    async getOptimalLineup(settings = {
        budget: 50000,
        scoring: 'ppr',
        positions: ['QB', 'RB', 'RB', 'WR', 'WR', 'TE', 'FLEX', 'DST']
    }) {
        try {
            const allPlayers = await this.getAllActivePlayers();
            const projections = await this.getPlayerProjectionsBatch(
                allPlayers.map(p => p.id)
            );

            const eligiblePlayers = allPlayers.map(player => ({
                ...player,
                projection: projections[player.id] || 0,
                value: this.calculatePlayerValue(player, projections[player.id])
            })).filter(p => p.projection > 0);

            return this.optimizeLineup(eligiblePlayers, settings);
        } catch (error) {
            console.error('Error generating optimal lineup:', error);
            throw error;
        }
    }

    calculatePlayerValue(player, projection) {
        return {
            raw: projection,
            perDollar: projection / player.salary,
            confidence: this.calculateProjectionConfidence(player)
        };
    }

    calculateProjectionConfidence(player) {
        // Implement confidence calculation based on:
        // - Historical accuracy
        // - Matchup difficulty
        // - Injury status
        // - Weather conditions
        // Returns value 0-1

        // Simple confidence score based on available data
        let confidence = 0.5; // Base confidence

        // Adjust based on games played
        if (player.experience > 2) confidence += 0.1;
        if (player.status?.type === 'active') confidence += 0.2;
        if (!player.injuries?.length) confidence += 0.2;

        return Math.min(confidence, 1.0);
    }

    optimizeLineup(players, settings) {
        const lineup = {
            totalSalary: 0,
            projectedPoints: 0,
            players: {}
        };

        // Implement knapsack algorithm for lineup optimization
        // Consider:
        // - Position requirements
        // - Salary constraints
        // - Player correlations
        // - Stack opportunities

        return lineup;
    }

    // BETTING PREDICTION METHODS

    async getPredictionInsights(gameId) {
        const [
            gameDetails,
            homeTeamStats,
            awayTeamStats,
            historicalMatchups,
            injuries
        ] = await Promise.all([
            this.getGameDetails(gameId),
            this.getTeamBettingStats(gameDetails.homeTeam.id),
            this.getTeamBettingStats(gameDetails.awayTeam.id),
            this.getHistoricalMatchups(gameDetails.homeTeam.id, gameDetails.awayTeam.id),
            this.getTeamInjuryImpact([gameDetails.homeTeam.id, gameDetails.awayTeam.id])
        ]);

        return {
            spread: this.predictSpread(homeTeamStats, awayTeamStats, injuries),
            totalScore: this.predictTotalScore(homeTeamStats, awayTeamStats, gameDetails),
            winProbability: this.calculateWinProbability(homeTeamStats, awayTeamStats),
            keyFactors: this.analyzeKeyFactors(homeTeamStats, awayTeamStats, historicalMatchups),
            confidence: this.calculatePredictionConfidence(gameId)
        };
    }

    async getHistoricalMatchups(team1Id, team2Id, seasons = 3) {
        const matchups = await this.fetchWithCache(
            `${this.baseUrls.site}/teams/${team1Id}/schedule?season=${new Date().getFullYear()}`
        );

        return matchups?.events?.filter(event =>
            event.competitions[0].competitors.some(c => c.id === team2Id)
        ) || [];
    }

    async getTeamInjuryImpact(teamIds) {
        // Analyze impact of injuries on team performance
        const injuries = {};
        for (const teamId of teamIds) {
            const teamInjuries = await this.fetchWithCache(
                `${this.baseUrls.core}/teams/${teamId}/injuries`
            );
            injuries[teamId] = teamInjuries?.length || 0;
        }
        return injuries;
    }

    predictSpread(homeStats, awayStats, injuries) {
        // Implement spread prediction algorithm considering:
        // - Team performance metrics
        // - Home field advantage
        // - Injury impacts
        // - Weather conditions
        // - Historical ATS performance

        // Simple spread prediction based on points differential
        const homePointsDiff = homeStats.offense.pointsPerGame.value -
            awayStats.defense.pointsAllowedPerGame.value;
        const awayPointsDiff = awayStats.offense.pointsPerGame.value -
            homeStats.defense.pointsAllowedPerGame.value;

        const spread = homePointsDiff - awayPointsDiff + 3; // Add home field advantage
        return Math.round(spread * 10) / 10;
    }

    predictTotalScore(homeStats, awayStats, gameDetails) {
        // Implement total score prediction considering:
        // - Team scoring trends
        // - Pace of play
        // - Weather impact
        // - Defense vs position stats

        // Simple over/under prediction
        const predictedTotal =
            homeStats.offense.pointsPerGame.value +
            awayStats.offense.pointsPerGame.value;

        return Math.round(predictedTotal);
    }

    // REAL-TIME TRACKING AND UPDATES

    async startLiveGameTracking(gameId) {
        if (this.liveGameData.has(gameId)) {
            return;
        }

        const updateInterval = setInterval(async () => {
            try {
                const gameData = await this.getLiveGameData(gameId);
                this.liveGameData.set(gameId, gameData);
                this.notifySubscribers('gameUpdate', { gameId, data: gameData });

                // Update predictions based on live data
                const updatedPredictions = await this.updateLivePredictions(gameId, gameData);
                this.notifySubscribers('predictionUpdate', { gameId, predictions: updatedPredictions });

            } catch (error) {
                console.error(`Error tracking game ${gameId}:`, error);
            }
        }, CONFIG.UI.UPDATE_INTERVALS.LIVE);

        this.liveGameData.set(gameId, { updateInterval });
    }

    stopLiveGameTracking(gameId) {
        const gameData = this.liveGameData.get(gameId);
        if (gameData?.updateInterval) {
            clearInterval(gameData.updateInterval);
            this.liveGameData.delete(gameId);
        }
    }

    async updateLivePredictions(gameId, liveData) {
        // Update predictions based on live game data
        // Consider:
        // - Score
        // - Time remaining
        // - Possession
        // - Momentum
        // - Key events

        const predictions = await this.getPredictionInsights(gameId);
        const timeRemaining = this.calculateRemainingTime(liveData);
        const scoreDiff = liveData.score.home - liveData.score.away;

        return {
            ...predictions,
            adjustedSpread: this.adjustSpreadForLiveGame(predictions.spread, scoreDiff, timeRemaining),
            adjustedTotal: this.adjustTotalForLiveGame(predictions.totalScore,
                liveData.score.home + liveData.score.away, timeRemaining)
        };
    }

    // ADVANCED STATISTICS PROCESSING

    calculateAdvancedStats(rawStats) {
        return {
            efficiency: {
                passingSuccess: this.calculatePassingEfficiency(rawStats),
                rushingSuccess: this.calculateRushingEfficiency(rawStats),
                redZone: this.calculateRedZoneEfficiency(rawStats)
            },
            situational: {
                thirdDowns: this.calculateSituationalEfficiency(rawStats, '3rd'),
                redZone: this.calculateSituationalEfficiency(rawStats, 'RZ'),
                twoMinute: this.calculateSituationalEfficiency(rawStats, '2min')
            },
            trends: {
                scoring: this.analyzeScoringTrends(rawStats),
                momentum: this.analyzeMomentumFactors(rawStats)
            }
        };
    }
}


export default NFLDataService;

--------------------------------------------------------------------------------
FILE: scripts\core\config.js
--------------------------------------------------------------------------------
// config.js
const CONFIG = {
    API: {
        BASE_URL: 'https://sports.core.api.espn.com/v2/sports/football/leagues/nfl',
        SITE_URL: 'https://site.api.espn.com/apis/site/v2/sports/football/nfl',
        RATE_LIMIT: 30,
        RATE_INTERVAL: 60000
    },
    CACHE: {
        DURATIONS: {
            LIVE: 60,     // 1 minute
            STATS: 3600,  // 1 hour
            STATIC: 86400 // 24 hours
        }
    },
    UI: {
        MAX_DISPLAY: {
            TEAMS: 5,
            PLAYERS: 5
        },
        UPDATE_INTERVALS: {
            LIVE: 30000,    // 30 seconds
            DASHBOARD: 300000 // 5 minutes
        }
    },
    SCORING: {
        PPR: {
            PASS_YD: 0.04,
            PASS_TD: 4,
            INT: -2,
            RUSH_YD: 0.1,
            RUSH_TD: 6,
            REC: 1,
            REC_YD: 0.1,
            REC_TD: 6,
            FUMBLE: -2
        }
    }
};

export default CONFIG;

--------------------------------------------------------------------------------
FILE: scripts\core\storage.js
--------------------------------------------------------------------------------
// storage.js
class StorageManager {
    constructor() {
        this.dbName = 'LTRFantasy';
        this.dbVersion = 1;
        this.db = null;
        this.stores = {
            players: 'players',
            teams: 'teams',
            lineups: 'lineups',
            stats: 'stats',
            cache: 'cache'
        };
        this.readyPromise = this.initDB();
        this.fallbackToLocalStorage = false;
    }

    async initDB() {
        try {
            return new Promise((resolve, reject) => {
                console.log('Initializing IndexedDB...');
                const request = indexedDB.open(this.dbName, this.dbVersion);

                request.onerror = (event) => {
                    console.error('IndexedDB initialization error:', event.target.error);
                    this.fallbackToLocalStorage = true;
                    resolve(); // Resolve anyway to continue with localStorage
                };

                request.onupgradeneeded = (event) => {
                    console.log('IndexedDB upgrade needed');
                    const db = event.target.result;
                    
                    Object.values(this.stores).forEach(storeName => {
                        if (!db.objectStoreNames.contains(storeName)) {
                            console.log(`Creating store: ${storeName}`);
                            if (storeName === this.stores.cache) {
                                const store = db.createObjectStore(storeName, { keyPath: 'key' });
                                store.createIndex('timestamp', 'timestamp', { unique: false });
                            } else {
                                db.createObjectStore(storeName, { 
                                    keyPath: 'id',
                                    autoIncrement: true 
                                });
                            }
                        }
                    });
                };

                request.onsuccess = (event) => {
                    this.db = event.target.result;
                    console.log('IndexedDB initialized successfully:', {
                        name: this.db.name,
                        version: this.db.version,
                        stores: [...this.db.objectStoreNames]
                    });
                    resolve(this.db);
                };
            });
        } catch (error) {
            console.error('Critical IndexedDB error:', error);
            this.fallbackToLocalStorage = true;
            return Promise.resolve();
        }
    }

    async ensureReady() {
        await this.readyPromise;
    }

    // Cache methods
    async setCache(key, value, ttl = 3600) {
        await this.ensureReady();

        const data = {
            key,
            value,
            timestamp: Date.now(),
            expires: Date.now() + (ttl * 1000)
        };

        if (this.fallbackToLocalStorage) {
            console.log('Set cache fallback to localstorage');
            localStorage.setItem(key, JSON.stringify(data));
            return;
        }

        console.log(`Storing in cache:`, {
            key,
            ttl,
            expiresAt: new Date(data.expires).toLocaleString()
        });

        try {
            const tx = this.db.transaction(this.stores.cache, 'readwrite');
            const store = tx.objectStore(this.stores.cache);
            
            await new Promise((resolve, reject) => {
                const request = store.put(data);
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });

            // Verify
            const verify = await new Promise((resolve, reject) => {
                const request = store.get(key);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });

            console.log(`Cache write verified:`, verify ? 'success' : 'failed');
            return true;
        } catch (error) {
            console.error('Cache set error:', error);
            console.log('Falling back to localstorage');
            localStorage.setItem(key, JSON.stringify(data));
            return false;
        }
    }

    async getCache(key) {
        await this.ensureReady();
        console.log(`Checking cache for key: ${key}`);

        if (this.fallbackToLocalStorage) {
            console.log('Using localStorage fallback');
            const data = localStorage.getItem(key);
            if (!data) {
                console.log('No data in localStorage');
                return null;
            }
            const parsed = JSON.parse(data);
            if (Date.now() > parsed.expires) {
                console.log('Data expired in localStorage');
                localStorage.removeItem(key);
                return null;
            }
            console.log('Found valid data in localStorage');
            return parsed.value;
        }

        try {
            const tx = this.db.transaction(this.stores.cache, 'readonly');
            const store = tx.objectStore(this.stores.cache);


            // Properly wrap IDBRequest in a Promise
            const data = await new Promise((resolve, reject) => {
                const request = store.get(key);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });

            console.log('IndexedDB query result:', data);

            if (!data) {
                console.log('No data in IndexedDB');
                return null;
            }

            if (Date.now() > data.expires) {
                console.log('Data expired in IndexedDB');
                // Remove expired data
                const deleteTx = this.db.transaction(this.stores.cache, 'readwrite');
                const deleteStore = deleteTx.objectStore(this.stores.cache);
                await deleteStore.delete(key);
                return null;
            }

            console.log('Found valid data in IndexedDB');
            return data.value;
        } catch (error) {
            console.error('Cache get error:', error);
            return null;
        }
    }

    async clearExpiredCache() {
        try {
            const tx = this.db.transaction(this.stores.cache, 'readwrite');
            const store = tx.objectStore(this.stores.cache);
            const index = store.index('timestamp');
            const now = Date.now();

            // Fix: Use a cursor to iterate through expired items
            const request = index.openCursor();
            request.onsuccess = (event) => {
                const cursor = event.target.result;
                if (cursor) {
                    const data = cursor.value;
                    if (data.expires && data.expires < now) {
                        store.delete(cursor.primaryKey);
                    }
                    cursor.continue();
                }
            };
        } catch (error) {
            console.error('Cache cleanup error:', error);
            // Don't throw - just log and continue
        }
    }


    // Player data methods
    async setPlayers(players, chunk = false) {
        await this.ensureReady();

        if (chunk) {
            const CHUNK_SIZE = 50;
            for (let i = 0; i < players.length; i += CHUNK_SIZE) {
                const playerChunk = players.slice(i, i + CHUNK_SIZE);
                await this.setPlayersChunk(playerChunk, i / CHUNK_SIZE);
            }
            await this.setCache('playerChunkCount', Math.ceil(players.length / CHUNK_SIZE));
        } else {
            try {
                const tx = this.db.transaction('players', 'readwrite');
                const store = tx.objectStore('players');
                for (const player of players) {
                    await store.put(player);
                }
            } catch (error) {
                console.error('Error storing players:', error);
                // Fallback to cache
                await this.setCache('players', players);
            }
        }
    }

    async setPlayersChunk(players, chunkIndex) {
        await this.ensureReady();
        try {
            const key = `players_chunk_${chunkIndex}`;
            await this.setCache(key, players);
        } catch (error) {
            console.error('Error storing player chunk:', error);
        }
    }

    async getPlayers(paginated = false, page = 0, pageSize = 50) {
        await this.ensureReady();
        try {
            if (this.fallbackToLocalStorage) {
                const players = await this.getCache('players');
                return players || [];
            }

            const tx = this.db.transaction('players', 'readonly');
            const store = tx.objectStore('players');

            if (paginated) {
                const allPlayers = await store.getAll();
                const start = page * pageSize;
                return allPlayers.slice(start, start + pageSize);
            } else {
                return await store.getAll();
            }
        } catch (error) {
            console.error('Error retrieving players:', error);
            // Fallback to cache
            const players = await this.getCache('players');
            return players || [];
        }
    }

    // Lineup methods
    async saveLineup(lineup) {
        try {
            const tx = this.db.transaction(this.stores.lineups, 'readwrite');
            const store = tx.objectStore(this.stores.lineups);
            await store.put(lineup);
        } catch (error) {
            console.error('Error saving lineup:', error);
        }
    }

    async saveLineup(lineup) {
        return this.setCache('current_lineup', lineup);
    }

    async getLineup() {
        return this.getCache('current_lineup') || [];
    }

    async getLineups() {
        try {
            const tx = this.db.transaction(this.stores.lineups, 'readonly');
            const store = tx.objectStore(this.stores.lineups);
            return await store.getAll();
        } catch (error) {
            console.error('Error retrieving lineups:', error);
            return [];
        }
    }

    // Export/Import methods
    async exportData() {
        try {
            const data = {
                lineups: await this.getLineups(),
                timestamp: Date.now()
            };
            const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
            return blob;
        } catch (error) {
            console.error('Error exporting data:', error);
            return null;
        }
    }

    async importData(jsonData) {
        try {
            const data = JSON.parse(jsonData);
            const tx = this.db.transaction(this.stores.lineups, 'readwrite');
            const store = tx.objectStore(this.stores.lineups);

            // Clear existing lineups
            await store.clear();

            // Import new lineups
            for (const lineup of data.lineups) {
                await store.add(lineup);
            }

            return true;
        } catch (error) {
            console.error('Error importing data:', error);
            return false;
        }
    }

    // Clear all data
    async clearAllData() {
        try {
            const tx = this.db.transaction(
                [this.stores.players, this.stores.teams, this.stores.lineups, this.stores.stats, this.stores.cache],
                'readwrite'
            );

            await Promise.all([
                tx.objectStore(this.stores.players).clear(),
                tx.objectStore(this.stores.teams).clear(),
                tx.objectStore(this.stores.lineups).clear(),
                tx.objectStore(this.stores.stats).clear(),
                tx.objectStore(this.stores.cache).clear()
            ]);

            return true;
        } catch (error) {
            console.error('Error clearing data:', error);
            return false;
        }
    }
}

export default StorageManager;

--------------------------------------------------------------------------------
FILE: scripts\core\utils.js
--------------------------------------------------------------------------------
// core/utils.js
import CONFIG from './config.js';

const REQUIRED_API_FIELDS = {
    PLAYER: ['id', 'fullName', 'position'],
    TEAM: ['id', 'name', 'abbreviation'],
    GAME: ['id', 'homeTeam', 'awayTeam', 'startTime'],
    ODDS: ['spread', 'moneyline', 'overUnder']
};

// Data validation
export const validateApiResponse = (data, type) => {
    if (!data) {
        console.warn(`Empty data received for ${type}`);
        return false;
    }

    if (typeof data !== 'object') {
        console.warn(`Invalid data type received for ${type}: ${typeof data}`);
        return false;
    }

    const requiredFields = REQUIRED_API_FIELDS[type];
    const hasFields = requiredFields.some(field => data.hasOwnProperty(field));

    if (!hasFields) {
        console.debug(`Missing required fields for ${type}:`, requiredFields);
        return false;
    }

    return true;
};

// New data validation (will i use it idk)

// export const validateApiResponse = (data, type) => {
//     if (!data) return false;
//     return typeof data === 'object';
// };

// Old formatters

// export const formatters = {
//     currency: (amount) => new Intl.NumberFormat('en-US', {
//         style: 'currency',
//         currency: 'USD'
//     }).format(amount),

//     percentage: (value) => `${(value * 100).toFixed(1)}%`,

//     date: (date) => new Intl.DateTimeFormat('en-US').format(new Date(date))
// };

// Formatting utilities
export const formatters = {
    currency: (amount) => new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
        minimumFractionDigits: 0
    }).format(amount),

    percentage: (value) => `${(value * 100).toFixed(1)}%`,

    score: (value) => value?.toString() || '0',

    playerName: (firstName, lastName) => `${firstName} ${lastName}`,

    dateTime: (isoString) => {
        const date = new Date(isoString);
        return date.toLocaleString('en-US', {
            weekday: 'short',
            month: 'short',
            day: 'numeric',
            hour: 'numeric',
            minute: '2-digit'
        });
    }
};

// Dont need this anymore

// export const calculators = {
//     fantasyPoints: (stats) => {
//         // Fantasy scoring logic
//     },

//     winProbability: (teamStats, opponentStats) => {
//         // Win probability calculation
//     }
// };


// Fantasy scoring calculations
export const calculateFantasyPoints = (stats, scoring = 'PPR') => {
    const scoringRules = CONFIG.SCORING[scoring];
    if (!stats) return 0;

    return (
        (stats.passing?.yards?.value || 0) * scoringRules.PASS_YD +
        (stats.passing?.touchdowns?.value || 0) * scoringRules.PASS_TD +
        (stats.passing?.interceptions?.value || 0) * scoringRules.INT +
        (stats.rushing?.yards?.value || 0) * scoringRules.RUSH_YD +
        (stats.rushing?.touchdowns?.value || 0) * scoringRules.RUSH_TD +
        (stats.receiving?.receptions?.value || 0) * scoringRules.REC +
        (stats.receiving?.yards?.value || 0) * scoringRules.REC_YD +
        (stats.receiving?.touchdowns?.value || 0) * scoringRules.REC_TD
    );
};

// DOM utilities
export const createElement = (tag, className, textContent = '') => {
    const element = document.createElement(tag);
    if (className) element.className = className;
    if (textContent) element.textContent = textContent;
    return element;
};

export const clearElement = (element) => {
    while (element.firstChild) {
        element.removeChild(element.firstChild);
    }
};

// Error handling
export const handleError = (error, context) => {
    console.error(`Error in ${context}:`, error);
    // Could add error reporting service here
    return null;
};

// Data sorting
export function sortBy(array, keyOrFn, descending = false) {
    return array.sort((a, b) => {
        const aValue = typeof keyOrFn === 'function' ? keyOrFn(a) : a[keyOrFn];
        const bValue = typeof keyOrFn === 'function' ? keyOrFn(b) : b[keyOrFn];

        if (typeof aValue === 'number' && typeof bValue === 'number') {
            return descending ? bValue - aValue : aValue - bValue;
        } else if (typeof aValue === 'string' && typeof bValue === 'string') {
            return descending ? bValue.localeCompare(aValue) : aValue.localeCompare(bValue);
        } else {
            return 0;
        }
    });
}




export default {
    validateApiResponse,
    formatters,
    calculateFantasyPoints,
    createElement,
    clearElement,
    handleError,
    sortBy
};

export const showLoading = () => {
    document.getElementById('loading-overlay')?.classList.remove('hidden');
    updateFooter('Loading...');
};

export const hideLoading = () => {
    document.getElementById('loading-overlay')?.classList.add('hidden');
};

export const updateFooter = (message) => {
    const footer = document.getElementById('last-updated');
    if (footer) {
        footer.textContent = `${message} • ${new Date().toLocaleTimeString()}`;
    }
};


// Debug logger utility

export const DebugLogger = {
    logs: [],
    maxLogs: 1000,

    log(type, message, data = null) {
        const entry = {
            timestamp: new Date().toISOString(),
            type,
            message,
            data: data ? JSON.stringify(data, null, 2) : null
        };
        
        this.logs.push(entry);
        if (this.logs.length > this.maxLogs) {
            this.logs.shift();
        }
        
        console.log(`[${type}] ${message}`, data || '');
    },

    copyToClipboard() {
        const output = this.logs.map(entry => 
            `${entry.timestamp} [${entry.type}] ${entry.message}\n${entry.data ? entry.data : ''}`
        ).join('\n\n');
        
        navigator.clipboard.writeText(output)
            .then(() => console.log('Debug logs copied to clipboard'))
            .catch(err => console.error('Failed to copy logs:', err));
    },

    addCopyButton() {
        const button = document.createElement('button');
        button.textContent = 'Copy Debug Logs';
        button.style.cssText = 'position:fixed;bottom:10px;right:10px;z-index:9999';
        button.onclick = () => this.copyToClipboard();
        document.body.appendChild(button);
    }
};


--------------------------------------------------------------------------------
FILE: scripts\pages\dashboard.js
--------------------------------------------------------------------------------
// pages/dashboard.js  (my code is a mess i know lol have fun reading this)
import NFLDataService from '../core/api.js';
import StorageManager from '../core/storage.js';
import { formatters, createElement, clearElement, handleError, sortBy, showLoading, hideLoading, updateFooter, DebugLogger } from '../core/utils.js';

class DashboardManager {
    constructor() {
        DebugLogger.log('Init', 'DashboardManager initialized');
        this.api = new NFLDataService();
        this.storage = new StorageManager();
        this.containers = {
            liveGames: document.getElementById('live-games-container'),
            topTeams: document.querySelector('.teams-grid'),
            topPlayers: document.querySelector('.players-grid'),
            insights: document.getElementById('insights-container'),
            trends: document.getElementById('trends-container')
        };
        this.updateInterval = null;

        // Test storage for no reason
        try {
            this.storage.setCache('test_key', { test: 'data' });
            const testData = this.storage.getCache('test_key');
            console.log('Storage test:', testData ? 'working' : 'failed');
        } catch (error) {
            console.error('Storage test failed:', error);
        }
    }

    async init() {
        try {
            DebugLogger.log('Loading', 'Starting dashboard initialization');
            showLoading();

            // Ensure storage and API are initialized
            await this.storage.ensureReady();
            await this.api.init();

            const teams = await this.api.getAllTeams();
            if (!teams?.length) {
                throw new Error('Failed to initialize - no teams data available');
            }

            await this.loadAllSections();

            updateFooter('Dashboard initialized successfully');
        } catch (error) {
            console.error('Dashboard initialization error:', error);
            updateFooter('Error loading dashboard');
            DebugLogger.log('Error', 'Dashboard initialization failed', error);
        } finally {
            hideLoading();
        }
    }

    cleanup() {
        if (this.updateInterval) {
            clearInterval(this.updateInterval);
        }
        // Clear any event listeners
        Object.values(this.containers).forEach(container => {
            if (container) {
                container.replaceWith(container.cloneNode(true));
            }
        });
    }

    async loadAdditionalData() {
        // Load other sections in the background
        try {
            if (this.containers.liveGames) {
                this.containers.liveGames.innerHTML = '<div class="loading">Loading games...</div>';
            }
            // Additional data loading will go here
        } catch (error) {
            console.error('Error loading additional data:', error);
        }
    }

    // async loadAllSections() {
    //     try {
    //         await Promise.all([
    //             this.updateLiveGames(),
    //             this.updateTopTeams(),
    //             this.updateTopPlayers(),
    //             this.updateInsights()
    //         ]);
    //     } catch (error) {
    //         handleError(error, 'Dashboard loadAllSections');
    //     }
    // }

    // SIIIIIIIKKKKKKKKKEEEEEEEEEEEE

    async loadAllSections() {
        try {
            showLoading();

            // Load sections independently to show partial data
            const loadSection = async (section) => {
                try {
                    await section();
                    return true;
                } catch (error) {
                    console.warn(`Error loading section:`, error);
                    return false;
                }
            };

            const results = await Promise.allSettled([
                loadSection(() => this.updateLiveGames()),
                loadSection(() => this.updateTopTeams()),
                loadSection(() => this.updateTopPlayers()),
                loadSection(() => this.updateInsights())
            ]);

            const successCount = results.filter(r => r.status === 'fulfilled' && r.value).length;
            updateFooter(`Loaded ${successCount}/4 sections successfully`);

        } catch (error) {
            handleError(error, 'Dashboard loadAllSections');
            updateFooter('Error loading dashboard sections');
        } finally {
            hideLoading();
        }
    }

    // async updateLiveGames() {
    //     try {
    //         const games = await this.api.getLiveGameData();
    //         clearElement(this.containers.liveGames);

    //         games.forEach(game => {
    //             const gameElement = this.createGameElement(game);
    //             this.containers.liveGames.appendChild(gameElement);
    //         });
    //     } catch (error) {
    //         handleError(error, 'updateLiveGames');
    //     }
    // }

    async updateLiveGames() {
        try {
            console.log('Fetching live games...');
            const data = await this.api.getLiveGameData();
            console.log('Received live games:', data);

            if (!this.containers.liveGames) {
                console.warn('Live games container not found');
                return;
            }

            clearElement(this.containers.liveGames);

            const events = data?.events || [];
            if (events.length === 0) {
                this.containers.liveGames.innerHTML = '<div class="no-games">No live games at the moment</div>';
                return;
            }

            events.forEach(event => {
                const { competitions } = event;
                if (!competitions || !competitions[0]) return;

                const gameData = {
                    homeTeam: {
                        name: competitions[0].competitors[0]?.team?.name || 'Unknown Team',
                        score: competitions[0].competitors[0]?.score || '0',
                        logo: competitions[0].competitors[0]?.team?.logo || 'images/genericLogo.jpg'
                    },
                    awayTeam: {
                        name: competitions[0].competitors[1]?.team?.name || 'Unknown Team',
                        score: competitions[0].competitors[1]?.score || '0',
                        logo: competitions[0].competitors[1]?.team?.logo || 'images/genericLogo.jpg'
                    },
                    status: event.status?.type?.detail || 'Unknown Status',
                    startTime: event.date
                };

                const gameElement = this.createGameElement(gameData);
                if (gameElement) {
                    this.containers.liveGames.appendChild(gameElement);
                }
            });

            console.log('Live games updated successfully');
        } catch (error) {
            console.error('Error updating live games:', error);
            if (this.containers.liveGames) {
                this.containers.liveGames.innerHTML = '<div class="error">Error loading live games</div>';
            }
        }
    }

    // async updateTopTeams() {
    //     try {
    //         const teams = await this.api.getAllTeams();
    //         clearElement(this.containers.topTeams);

    //         teams.slice(0, 5).forEach(team => {
    //             const teamElement = this.createTeamElement(team);
    //             this.containers.topTeams.appendChild(teamElement);
    //         });
    //     } catch (error) {
    //         handleError(error, 'updateTopTeams');
    //     }
    // }

    // Adding more debug to this one too..

    // async updateTopTeams() {
    //     try {
    //         console.log('Fetching teams...');
    //         const teams = await this.api.getAllTeams();
    //         console.log('Received teams:', teams);

    //         if (!this.containers.topTeams) {
    //             console.error('Top teams container not found');
    //             return;
    //         }

    //         clearElement(this.containers.topTeams);

    //         if (!teams || teams.length === 0) {
    //             console.log('No teams available');
    //             this.containers.topTeams.innerHTML = '<div class="no-data">No teams available</div>';
    //             return;
    //         }

    //         // Take top 5 teams
    //         const topTeams = teams.slice(0, 5);
    //         topTeams.forEach(team => {
    //             const teamElement = this.createTeamElement(team);
    //             if (teamElement) {
    //                 this.containers.topTeams.appendChild(teamElement);
    //             }
    //         });

    //         console.log('Teams displayed successfully');
    //     } catch (error) {
    //         console.error('Error updating teams:', error);
    //         if (this.containers.topTeams) {
    //             this.containers.topTeams.innerHTML = '<div class="error">Error loading teams</div>';
    //         }
    //     }
    // }

    // Anndd changing it again

    async updateTopTeams() {
        try {
            const teams = await this.api.getAllTeams();
    
            if (!this.containers.topTeams) {
                console.error('Top teams container not found');
                return;
            }
    
            clearElement(this.containers.topTeams);
    
            if (!teams || teams.length === 0) {
                this.containers.topTeams.innerHTML = '<div class="no-data">No teams available</div>';
                return;
            }
    
            // Fetch detailed records for each team
            const enhancedTeams = await Promise.all(
                teams.map(async (teamData) => {
                    const team = teamData.team;
    
                    try {
                        // Fetch the record details from the record endpoint
                        const recordResponse = await fetch(
                            `https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2024/types/2/teams/${team.id}/record`
                        );
                        const recordData = await recordResponse.json();
    
                        // Locate the "overall" record using the "name" field
                        const overallRecord = recordData.items.find((record) => record.name === 'overall');
    
                        // Extract wins, losses, and ties from stats
                        const winsStat = overallRecord?.stats.find(stat => stat.name === 'wins');
                        const lossesStat = overallRecord?.stats.find(stat => stat.name === 'losses');
                        const tiesStat = overallRecord?.stats.find(stat => stat.name === 'ties');
    
                        const wins = winsStat?.value || 0;
                        const losses = lossesStat?.value || 0;
                        const ties = tiesStat?.value || 0;
    
                        const totalGames = wins + losses + ties;
                        const winLossRatio = totalGames > 0 ? wins / totalGames : 0;
    
                        return {
                            ...team,
                            wins,
                            losses,
                            ties,
                            winLossRatio,
                        };
                    } catch (recordError) {
                        console.error(`Failed to fetch record for team ${team.id}:`, recordError);
                        return {
                            ...team,
                            wins: 0,
                            losses: 0,
                            ties: 0,
                            winLossRatio: 0,
                        };
                    }
                })
            );
    
            // Sort by win/loss ratio, then by losses in ascending order
            const sortedTeams = enhancedTeams.sort((a, b) => {
                if (b.winLossRatio === a.winLossRatio) {
                    return a.losses - b.losses; // Fewer losses rank higher
                }
                return b.winLossRatio - a.winLossRatio; // Higher win ratio ranks higher
            });
    
            // Get top 5 teams
            const topTeams = sortedTeams.slice(0, 5);
    
            // Display the top 5 teams
            topTeams.forEach((team) => {
                const teamElement = this.createTeamElement(team);
                if (teamElement) {
                    this.containers.topTeams.appendChild(teamElement);
                }
            });
    
            console.log('Top teams updated successfully');
        } catch (error) {
            console.error('Error updating teams:', error);
            if (this.containers.topTeams) {
                this.containers.topTeams.innerHTML = '<div class="error">Error loading teams</div>';
            }
        }
    }
    
    
    
    

    async updateTopPlayers() {
        try {
            console.log('Fetching active players...');
            const players = await this.api.getAllActivePlayers();

            // Enhance players with stats
            const enhancedPlayers = await this.enhancePlayersWithStats(players);

            // Sort players by fantasy points in descending order
            const sortedPlayers = sortBy(enhancedPlayers, 'fantasyPoints', true);

            // Take top 5 players
            const topPlayers = sortedPlayers.slice(0, 5);

            // Clear container
            clearElement(this.containers.topPlayers);

            // Create and append player elements
            for (const player of topPlayers) {
                const playerElement = await this.createPlayerElement(player);
                if (playerElement instanceof HTMLElement) {
                    this.containers.topPlayers.appendChild(playerElement);
                } else {
                    console.error('Invalid player element:', playerElement);
                }
            }

            console.log('Top players updated successfully');
        } catch (error) {
            handleError(error, 'updateTopPlayers');
        }
    }



    // Enhance a single player with stats (helper method)
    async enhancePlayersWithStats(players) {
        return Promise.all(players.map(async (player) => {
            try {
                const stats = await this.api.getPlayerFantasyStats(player.id);
                const fantasyPoints = await this.calculateFantasyPoints(stats);
                return { ...player, fantasyStats: stats, fantasyPoints };
            } catch (error) {
                console.warn(`Failed to load stats for player ${player.id}`, error);
                return { ...player, fantasyPoints: 0 };
            }
        }));
    }

    async calculateFantasyPoints(stats) {
        if (!stats) return 0;

        // Basic PPR scoring
        return (
            (stats.passing?.yards?.value || 0) * 0.04 +
            (stats.passing?.touchdowns?.value || 0) * 4 +
            (stats.rushing?.yards?.value || 0) * 0.1 +
            (stats.rushing?.touchdowns?.value || 0) * 6 +
            (stats.receiving?.receptions?.value || 0) * 1 +
            (stats.receiving?.yards?.value || 0) * 0.1 +
            (stats.receiving?.touchdowns?.value || 0) * 6
        );
    }

    async sortBy(array, key, descending = false) {
        return array.sort((a, b) => {
            const aValue = a[key] || 0;
            const bValue = b[key] || 0;
            return descending ? bValue - aValue : aValue - bValue;
        });
    }

    // startUpdateIntervals() {
    //     setInterval(() => this.updateLiveGames(), 30000);
    //     setInterval(() => this.loadAllSections(), 300000);
    // }

    startUpdateIntervals() {
        // Update live games every 30 seconds
        this.updateInterval = setInterval(() => {
            this.updateLiveGames();
        }, 30000);

        // Update all sections every 5 minutes
        setInterval(() => {
            this.loadAllSections();
        }, 300000);
    }

    // Add cleanup method
    cleanup() {
        if (this.updateInterval) {
            clearInterval(this.updateInterval);
        }
    }

    // createGameElement(game) {
    //     const element = createElement('div', 'game-card');
    //     element.innerHTML = `
    //         <div class="teams">
    //             <div class="team home">${game.homeTeam.name}: ${formatters.score(game.homeTeam.score)}</div>
    //             <div class="team away">${game.awayTeam.name}: ${formatters.score(game.awayTeam.score)}</div>
    //         </div>
    //         <div class="game-info">
    //             <div class="status">${game.status}</div>
    //             <div class="odds">Spread: ${game.spread || 'N/A'}</div>
    //         </div>
    //     `;
    //     return element;
    // }

    // Sike lol

    // createGameElement(game) {
    //     const element = createElement('div', 'game-card');
    //     element.innerHTML = `
    //         <div class="teams">
    //             <div class="team home">
    //                 <img src="${game.homeTeam.logo || 'images/genericLogo.jpg'}" alt="${game.homeTeam.name} logo" class="team-logo">
    //                 <span>${game.homeTeam.name}: ${game.homeTeam.score}</span>
    //             </div>
    //             <div class="team away">
    //                 <img src="${game.awayTeam.logo || 'images/genericLogo.jpg'}" alt="${game.awayTeam.name} logo" class="team-logo">
    //                 <span>${game.awayTeam.name}: ${game.awayTeam.score}</span>
    //             </div>
    //         </div>
    //         <div class="game-info">
    //             <div class="status">${game.status}</div>
    //             <div class="odds">Spread: ${game.spread ? game.spread : 'N/A'}</div>
    //         </div>
    //     `;
    //     return element;
    // }

    // Sike again lolol

    // createGameElement(game) {
    //     if (!game) return null;

    //     const element = createElement('div', 'game-card');
    //     try {
    //         element.innerHTML = `
    //             <div class="teams">
    //                 <div class="team home">
    //                     <img src="${game.homeTeam?.logo || 'images/genericLogo.jpg'}" 
    //                          alt="${game.homeTeam?.name || 'Team'} logo" 
    //                          class="team-logo">
    //                     <span>${game.homeTeam?.name || 'Unknown'}: ${game.homeTeam?.score || '0'}</span>
    //                 </div>
    //                 <div class="team away">
    //                     <img src="${game.awayTeam?.logo || 'images/genericLogo.jpg'}" 
    //                          alt="${game.awayTeam?.name || 'Team'} logo" 
    //                          class="team-logo">
    //                     <span>${game.awayTeam?.name || 'Unknown'}: ${game.awayTeam?.score || '0'}</span>
    //                 </div>
    //             </div>
    //             <div class="game-info">
    //                 <div class="status">${game.status || 'Status unknown'}</div>
    //                 <div class="odds">Spread: ${game.spread ? game.spread : 'N/A'}</div>
    //             </div>
    //         `;
    //         return element;
    //     } catch (error) {
    //         console.warn('Error creating game element:', error);
    //         element.innerHTML = '<div class="error">Error loading game data</div>';
    //         return element;
    //     }
    // }

    createGameElement(game) {
        const element = createElement('div', 'game-card');

        element.innerHTML = `
            <div class="game-teams">
                <div class="team-matchup">
                    <img src="${game.homeTeam.logo || 'images/genericLogo.jpg'}" 
                         alt="${game.homeTeam.name} logo" 
                         class="team-logo">
                    <div class="team-info">
                        <span class="team-name">${game.homeTeam.name}</span>
                        <span class="team-score">${game.homeTeam.score || '0'}</span>
                    </div>
                </div>
                <div class="vs">VS</div>
                <div class="team-matchup">
                    <div class="team-info">
                        <span class="team-name">${game.awayTeam.name}</span>
                        <span class="team-score">${game.awayTeam.score || '0'}</span>
                    </div>
                    <img src="${game.awayTeam.logo || 'images/genericLogo.jpg'}" 
                         alt="${game.awayTeam.name} logo" 
                         class="team-logo">
                </div>
            </div>
            <div class="game-status">
                ${game.status || 'Upcoming'} • ${formatters.dateTime(game.startTime)}
            </div>
        `;

        return element;
    }

    // createTeamElement(team) {
    //     const element = createElement('div', 'team-card');
    //     element.innerHTML = `
    //         <div class="team-header">
    //             <img src="${team.team.logos?.[0]?.href || 'images/genericLogo.jpg'}" 
    //                  alt="${team.team.name} logo" 
    //                  class="team-logo">
    //             <h3>${team.team.name}</h3>
    //         </div>
    //         <div class="team-stats">
    //             <div class="stat-row">
    //                 <span>Record:</span>
    //                 <span>${team.team.record?.overall || '0-0'}</span>
    //             </div>
    //             <div class="stat-row">
    //                 <span>PPG:</span>
    //                 <span>${team.team.statistics?.points?.avg || '0.0'}</span>
    //             </div>
    //             <div class="stat-row">
    //                 <span>PAPG:</span>
    //                 <span>${team.team.statistics?.pointsAgainst?.avg || '0.0'}</span>
    //             </div>
    //             <div class="stat-row">
    //                 <span>Streak:</span>
    //                 <span>${team.team.streak || 'N/A'}</span>
    //             </div>
    //         </div>
    //         <a href="teams.html?id=${team.team.id}" class="team-link">View Details</a>
    //     `;
    //     return element;
    // }

    // better or worse but.. simpler

    createTeamElement(team) {
        try {
            const element = createElement('div', 'team-card');
    
            // Hardcoded division and conference mapping
            const divisionConferenceMap = {
                "1": { division: "South", conference: "NFC" },
                "2": { division: "East", conference: "AFC" },
                "3": { division: "North", conference: "NFC" },
                "4": { division: "North", conference: "AFC" },
                "5": { division: "North", conference: "AFC" },
                "6": { division: "East", conference: "NFC" },
                "7": { division: "West", conference: "AFC" },
                "8": { division: "North", conference: "NFC" },
                "9": { division: "North", conference: "NFC" },
                "10": { division: "South", conference: "AFC" },
                "11": { division: "South", conference: "AFC" },
                "12": { division: "West", conference: "AFC" },
                "13": { division: "West", conference: "AFC" },
                "14": { division: "West", conference: "NFC" },
                "15": { division: "East", conference: "AFC" },
                "16": { division: "North", conference: "NFC" },
                "17": { division: "East", conference: "AFC" },
                "18": { division: "South", conference: "NFC" },
                "19": { division: "East", conference: "NFC" },
                "20": { division: "East", conference: "AFC" },
                "21": { division: "East", conference: "NFC" },
                "22": { division: "West", conference: "NFC" },
                "23": { division: "North", conference: "AFC" },
                "24": { division: "West", conference: "AFC" },
                "25": { division: "West", conference: "NFC" },
                "26": { division: "West", conference: "NFC" },
                "27": { division: "South", conference: "NFC" },
                "28": { division: "East", conference: "NFC" },
                "29": { division: "South", conference: "NFC" },
                "30": { division: "South", conference: "AFC" },
                "33": { division: "North", conference: "AFC" },
                "34": { division: "South", conference: "AFC" }
            };
    
            const teamId = team.id;
            const division = divisionConferenceMap[teamId]?.division || 'N/A';
            const conference = divisionConferenceMap[teamId]?.conference || 'N/A';
    
            const wins = team.wins || 0;
            const losses = team.losses || 0;
            const ties = team.ties || 0;
            const recordSummary = `${wins}-${losses}${ties > 0 ? `-${ties}` : ''}`;
    
            element.innerHTML = `
                <div class="team-header">
                    <img src="${team.logos?.[0]?.href || 'images/genericLogo.jpg'}" 
                         alt="${team.displayName || 'Team'} logo" 
                         class="team-logo">
                    <h3>${team.displayName || 'Unknown Team'}</h3>
                </div>
                <div class="team-info">
                    <div class="info-row">Location: ${team.location || 'N/A'}</div>
                    <div class="info-row">Division: ${conference} ${division}</div>
                    <div class="info-row">Record: ${recordSummary}</div>
                </div>
            `;
            return element;
        } catch (error) {
            console.error('Error creating team element:', error, team);
            return null;
        }
    }
    

    async createPlayerElement(player) {
        const element = createElement('div', 'player-card');

        const playerHeadshot = player.headshot || `https://a.espncdn.com/combiner/i?img=/i/headshots/nfl/players/full/${player.id}.png&h=150&w=150&scale=crop`;

        element.innerHTML = `
            <div class="player-header">
                <img src="${playerHeadshot}" alt="${player.fullName}" class="player-image">
                <h3>${player.fullName}</h3>
            </div>
            <div class="player-info">
                <div class="info-row"><span>Position:</span><span>${player.position}</span></div>
                <div class="info-row"><span>Team:</span><span>${player.team}</span></div>
                <div class="info-row"><span>Fantasy Pts:</span><span>${player.fantasyPoints?.toFixed(1) || '0.0'}</span></div>
            </div>
            <a href="players.html?id=${player.id}" class="player-link">View Details</a>
        `;

        return element;
    }





    async updateInsights() {
        try {
            const insights = await this.getInsights();
            clearElement(this.containers.insights);
    
            insights.forEach(insight => {
                const insightElement = createElement('div', 'insight-card');
                insightElement.innerHTML = `
                    <h4>${insight.title}</h4>
                    <p>${insight.description}</p>
                    <div class="insight-value">${insight.value}</div>
                `;
                this.containers.insights.appendChild(insightElement);
            });
        } catch (error) {
            handleError(error, 'updateInsights');
        }
    }
    

    async getInsights() {
        // Get relevant data for insights
        const [games, teams] = await Promise.all([
            this.api.getUpcomingGames(),
            this.api.getAllTeams()
        ]);
    
        // Generate insights based on data
        return [
            {
                title: 'Top Matchup',
                description: this.getTopMatchupDescription(games),
                value: this.getTopMatchupValue(games)
            },
            {
                title: 'Best Betting Value',
                description: this.getBestBettingDescription(games),
                value: this.getBestBettingValue(games)
            },
            {
                title: 'Fantasy Trend',
                description: 'Top performing team:',
                value: await this.getFantasyTrendValue(teams) // Ensure await is used
            }
        ];
    }
    

    getTopMatchupDescription(games) {
        const topGame = games[0]; // Assume first game is top matchup
        return topGame ?
            `${topGame.homeTeam.name} vs ${topGame.awayTeam.name}` :
            'No upcoming games';
    }

    getTopMatchupValue(games) {
        const topGame = games[0];
        return topGame ?
            formatters.dateTime(topGame.startTime) :
            'N/A';
    }

    getBestBettingDescription(games) {
        const bestBet = games.find(game => game.spread && game.overUnder);
    
        if (bestBet) {
            console.log('Best Bet Spread:', bestBet.spread);
        }
    
        return bestBet ?
            `${bestBet.homeTeam.name} (${bestBet.spread.line})` :
            'No betting lines available';
    }
    

    getBestBettingValue(games) {
        const bestBet = games.find(game => game.spread && game.overUnder);
        return bestBet ?
            `O/U ${bestBet.overUnder}` :
            'N/A';
    }

    // getFantasyTrendDescription(teams) {
    //     // Simplified trend analysis
    //     return teams.length > 0 ?
    //         `Top performing team: ${teams[0].team.name}` :
    //         'No trend data available';
    // }

    async getFantasyTrendValue(teams) {
        try {
            if (teams.length === 0) return 'No trend data available';
    
            const enhancedTeams = await this.enhanceTeamsWithPointsPerGame(teams);
    
            // Find the team with the highest PPG
            const highestPPGTeam = enhancedTeams.reduce((max, teamData) => {
                const team = teamData.team;
                return team.pointsPerGame > max.pointsPerGame ? team : max;
            }, { name: '', pointsPerGame: 0 });
    
            if (!highestPPGTeam.name) return 'No trend data available';
    
            return `${highestPPGTeam.name} ${highestPPGTeam.pointsPerGame.toFixed(1)} PPG`;
        } catch (error) {
            console.error('Error fetching Fantasy Trend Value:', error);
            return 'No trend data available';
        }
    }
    
    

    async enhanceTeamsWithPointsPerGame(teams) {
        return Promise.all(teams.map(async teamData => {
            const team = teamData.team;
            const teamId = team.id;
    
            try {
                // Fetch team betting stats
                const stats = await this.api.getTeamBettingStats(teamId);
    
                // Extract points per game from stats
                const pointsPerGame = stats?.offense?.pointsPerGame?.value || 0;
    
                return {
                    ...teamData,
                    team: {
                        ...team,
                        pointsPerGame,
                    },
                };
            } catch (error) {
                console.warn(`Failed to load stats for team ${teamId}`, error);
                return {
                    ...teamData,
                    team: {
                        ...team,
                        pointsPerGame: 0,
                    },
                };
            }
        }));
    }
}



export default DashboardManager;

--------------------------------------------------------------------------------
FILE: scripts\pages\lineups.js
--------------------------------------------------------------------------------
// pages/lineups.js
import NFLDataService from '../core/api.js';
import StorageManager from '../core/storage.js';
import { formatters, createElement, clearElement, handleError, sortBy, showLoading, hideLoading, updateFooter } from '../core/utils.js';

class LineupManager {
    constructor() {
        this.api = new NFLDataService();
        this.storage = new StorageManager();
        this.currentLineup = [];
        this.maxPlayers = 8; // Standard fantasy lineup size
        this.positions = {
            QB: { max: 1, label: 'Quarterback' },
            RB: { max: 2, label: 'Running Back' },
            WR: { max: 2, label: 'Wide Receiver' },
            TE: { max: 1, label: 'Tight End' },
            FLEX: { max: 1, label: 'Flex (RB/WR/TE)' },
            DST: { max: 1, label: 'Defense/Special Teams' }
        };
        this.availablePlayers = [];
        // this.init(); let main.js do this
    }

    async init() {
        this.setupEventListeners();
        await this.loadAvailablePlayers();
        await this.loadSavedLineup();
        this.renderLineup();
    }

    renderLineup() {
        const container = document.getElementById('lineup-container');
        container.innerHTML = this.currentLineup.map(player => `
            <div class="player-card">
                <h3>${player.fullName}</h3>
                <p>${player.position} - ${player.team}</p>
                <button onclick="lineupManager.removePlayer('${player.id}')">Remove</button>
            </div>
        `).join('');
    }

    addToLineup(playerId) {
        window.lineupManager.addPlayer(playerId);
    }

    async addPlayer(playerId) {
        if (this.currentLineup.length >= this.maxPlayers) {
            alert('Lineup full');
            return;
        }
    
        const players = await this.api.getAllActivePlayers();
        const player = players.find(p => p.id === playerId);
        
        if (!player) {
            console.error('Player not found:', playerId);
            return;
        }
    
        this.currentLineup.push(player);
        await this.storage.setCache('current_lineup', this.currentLineup);
        this.renderLineup();
    }

    removePlayer(playerId) {
        this.currentLineup = this.currentLineup.filter(p => p.id !== playerId);
        this.storage.setCache('current_lineup', this.currentLineup);
        this.renderLineup();
    }

    clearLineup() {
        this.currentLineup = [];
        this.storage.setCache('current_lineup', []);
        this.renderLineup();
    }

    cleanup() {
        if (this.saveInterval) {
            clearInterval(this.saveInterval);
        }
        // Remove drag-drop listeners if implemented
        const lineupContainer = document.getElementById('lineup-container');
        if (lineupContainer) {
            lineupContainer.replaceWith(lineupContainer.cloneNode(true));
        }
    }

    exportLineup() {
        const blob = new Blob([JSON.stringify(this.currentLineup)], {type: 'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'lineup.json';
        a.click();
    }
    
    importLineup(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            this.currentLineup = JSON.parse(e.target.result);
            this.renderLineup();
        };
        reader.readAsText(file);
    }
    
    clearData() {
        this.storage.clearAllData();
        this.currentLineup = {};
        this.renderLineup();
    }

    setupEventListeners() {
        document.querySelector('.lineup-form')?.addEventListener('submit', (e) => {
            e.preventDefault();
            this.saveLineup();
        });
        
        document.querySelector('[data-action="clear"]')?.addEventListener('click', () => 
            this.clearLineup());
        
        document.querySelector('[data-action="export"]')?.addEventListener('click', () => 
            this.exportLineup());
        
        document.querySelector('[data-action="import"]')?.addEventListener('change', (e) => 
            this.importLineup(e.target.files[0]));
            
        document.querySelector('[data-action="reset-all"]')?.addEventListener('click', () => {
            if(confirm('Are you sure you want to reset all data?')) {
                this.clearData();
            }
        });

        document.querySelectorAll('.add-player-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const playerId = e.target.dataset.playerId;
                this.addPlayer(playerId);
            });
        });
    }

    async loadAvailablePlayers() {
        try {
            showLoading();
            const players = await this.api.getAllActivePlayers();
            console.log('Got the players, enhancing with projections');
            //this.availablePlayers = await this.enhancePlayersWithProjections(players);
            //console.log('the projections finished so whats wrong?');
            this.updatePositionDropdowns();
            updateFooter('Available players loaded successfully');
        } catch (error) {
            handleError(error, 'loadAvailablePlayers');
            updateFooter(`Error loading players: ${error.message}`);
        } finally {
            hideLoading();
        }
    }

    async enhancePlayersWithProjections(players) {
        return Promise.all(players.map(async player => {
            try {
                // Use 2023 season instead of 2024
                const stats = await this.api.getPlayerFantasyStats(player.id); 
                return {
                    ...player,
                    projectedPoints: this.calculateProjectedPoints(stats) // Use actual stats as projection
                };
            } catch (error) {
                console.warn(`Using base player data for ${player.id}`);
                return player;
            }
        }));
    }

    calculateProjectedPoints(projections) {
        if (!projections) return 0;

        // PPR scoring
        return (
            (projections.passing?.yards?.value || 0) * 0.04 +
            (projections.passing?.touchdowns?.value || 0) * 4 +
            (projections.rushing?.yards?.value || 0) * 0.1 +
            (projections.rushing?.touchdowns?.value || 0) * 6 +
            (projections.receiving?.receptions?.value || 0) * 1 +
            (projections.receiving?.yards?.value || 0) * 0.1 +
            (projections.receiving?.touchdowns?.value || 0) * 6
        );
    }

    async loadSavedLineup() {
        const savedLineup = await this.storage.getCache('current_lineup');
        if (savedLineup) {
            this.currentLineup = savedLineup;
        }
    }

    saveLineup() {
        if (!this.validateLineup()) {
            alert('Please fill all required positions');
            return;
        }
        this.storage.saveLineup(this.currentLineup);
        alert('Lineup saved successfully!');
    }

    validateLineup() {
        return Object.entries(this.currentLineup).every(([position, player]) => {
            if (position !== 'FLEX') {
                return player !== null;
            }
            return true;
        });
    }

    async optimizeLineup() {
        try {
            const optimal = await this.api.getOptimalLineup();
            this.currentLineup = optimal;
            this.renderLineup();
            alert('Lineup optimized based on projections!');
        } catch (error) {
            handleError(error, 'optimizeLineup');
            alert('Failed to optimize lineup. Please try again.');
        }
    }

    // clearLineup() {
    //     this.currentLineup = Object.keys(this.currentLineup).reduce((acc, pos) => {
    //         acc[pos] = null;
    //         return acc;
    //     }, {});
    //     this.renderLineup();
    // }

    updatePosition(position, playerId) {
        if (playerId === '') {
            this.currentLineup[position] = null;
        } else {
            const player = this.availablePlayers.find(p => p.id === playerId);
            this.currentLineup[position] = player;
        }
        this.renderLineup();
    }

    updatePositionDropdowns() {
        Object.keys(this.currentLineup).forEach(position => {
            const select = document.getElementById(`${position}-select`);
            if (!select) return;

            clearElement(select);

            // Add empty option
            const emptyOption = createElement('option', '', '-- Select Player --');
            emptyOption.value = '';
            select.appendChild(emptyOption);

            // Add available players for position
            this.getEligiblePlayers(position).forEach(player => {
                const option = createElement('option', '', player.fullName);
                option.value = player.id;
                if (this.currentLineup[position]?.id === player.id) {
                    option.selected = true;
                }
                select.appendChild(option);
            });
        });
    }

    getEligiblePlayers(position) {
        if (position === 'FLEX') {
            return this.availablePlayers.filter(p => 
                ['RB', 'WR', 'TE'].includes(p.position) &&
                !Object.values(this.currentLineup).some(player => player?.id === p.id)
            );
        }

        return this.availablePlayers.filter(p => 
            p.position === position &&
            !Object.values(this.currentLineup).some(player => player?.id === p.id)
        );
    }

    // renderLineup() {
    //     const container = document.getElementById('lineup-container');
    //     if (!container) return;

    //     clearElement(container);

    //     // Render each position
    //     Object.entries(this.positions).forEach(([pos, info]) => {
    //         const positionElement = this.createPositionElement(pos, info);
    //         container.appendChild(positionElement);
    //     });

    //     // Update total projected points
    //     this.updateProjectedPoints();
    // }

    createPositionElement(position, info) {
        const element = createElement('div', 'position-slot');
        
        const players = position === 'RB' || position === 'WR' 
            ? [this.currentLineup[`${position}1`], this.currentLineup[`${position}2`]]
            : [this.currentLineup[position]];

        element.innerHTML = `
            <div class="position-header">
                <h4>${info.label}</h4>
                <span class="max-players">(Max: ${info.max})</span>
            </div>
            ${players.map((player, index) => `
                <div class="player-slot">
                    ${player ? this.renderPlayer(player) : 'Empty Slot'}
                    <select id="${position}${index + 1}-select" class="player-select">
                        <!-- Options populated by updatePositionDropdowns -->
                    </select>
                </div>
            `).join('')}
        `;

        return element;
    }

    renderPlayer(player) {
        return `
            <div class="selected-player">
                <img src="${player.headshot || 'images/genericProfilePic.jpg'}" 
                     alt="${player.fullName}" 
                     class="player-image">
                <div class="player-info">
                    <div class="player-name">${player.fullName}</div>
                    <div class="player-details">
                        ${player.team} - ${player.position}
                    </div>
                    <div class="projected-points">
                        Projected: ${player.projectedPoints?.toFixed(1) || '0.0'}
                    </div>
                </div>
            </div>
        `;
    }

    updateProjectedPoints() {
        const totalPoints = Object.values(this.currentLineup)
            .reduce((total, player) => {
                return total + (player?.projectedPoints || 0);
            }, 0);

        const pointsElement = document.getElementById('total-projected-points');
        if (pointsElement) {
            pointsElement.textContent = `Total Projected Points: ${totalPoints.toFixed(1)}`;
        }
    }
}



export default LineupManager;


--------------------------------------------------------------------------------
FILE: scripts\pages\players.js
--------------------------------------------------------------------------------
// pages/players.js
import NFLDataService from '../core/api.js';
import StorageManager from '../core/storage.js';
import { formatters, createElement, clearElement, handleError, sortBy, showLoading, hideLoading, updateFooter } from '../core/utils.js';

class PlayersManager {
    constructor() {
        this.api = new NFLDataService();
        this.storage = new StorageManager();
        this.players = [];
        this.filters = {
            position: 'ALL',
            team: 'ALL',
            search: ''
        };
        this.cacheKey = 'players_data';
    }

    async init() {
        this.setupEventListeners();
        await this.loadPlayers();
    }

    cleanup() {
        const searchInput = document.getElementById('player-search');
        if (searchInput) {
            searchInput.removeEventListener('input', this.handleSearch);
        }
        // Clear filter event listeners
        ['position-filter', 'team-filter', 'sort-options'].forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.replaceWith(element.cloneNode(true));
            }
        });
    }

    setupEventListeners() {
        document.getElementById('player-search')?.addEventListener('input', (e) => {
            this.filters.search = e.target.value;
            this.renderPlayers();
        });

        document.getElementById('position-filter')?.addEventListener('change', (e) => {
            this.filters.position = e.target.value;
            this.renderPlayers();
        });

        document.getElementById('team-filter')?.addEventListener('change', (e) => {
            this.filters.team = e.target.value;
            this.renderPlayers();
        });

        document.getElementById('sort-options')?.addEventListener('change', (e) => {
            this.renderPlayers(e.target.value);
        });
    }

    async loadPlayers() {
        try {
            showLoading();
    
            // Attempt to load from cache
            const cachedPlayers = await this.storage.getCache(this.cacheKey);
            const container = document.getElementById('players-container');
            clearElement(container); // Clear previous content
    
            if (cachedPlayers) {
                // Render cached players incrementally
                cachedPlayers.forEach(player => {
                    const playerCard = this.createPlayerCard(player);
                    container.appendChild(playerCard);
                });
    
                this.players = cachedPlayers;
                updateFooter('Loaded players from cache.');
            } else {
                // Fetch from API if cache is unavailable
                const players = await this.api.getAllActivePlayers();
                this.players = [];
                
                // Render each player as they load and enhance them
                for (const player of players) {
                    const enhancedPlayer = await this.enhancePlayerWithStats(player);
                    this.players.push(enhancedPlayer);
    
                    // Render incrementally
                    const playerCard = this.createPlayerCard(enhancedPlayer);
                    container.appendChild(playerCard);
                }
    
                // Cache the players' data
                await this.storage.setCache(this.cacheKey, this.players, 86400); // Cache for 1 day
                updateFooter('Player data loaded successfully.');
            }
        } catch (error) {
            handleError(error, 'loadPlayers');
            updateFooter(`Error loading players: ${error.message}`);
        } finally {
            hideLoading();
        }
    }
    

    async enhancePlayerWithStats(player) {
        try {
            const stats = await this.api.getPlayerFantasyStats(player.id);
            return {
                ...player,
                fantasyStats: stats,
                fantasyPoints: this.calculateFantasyPoints(stats)
            };
        } catch (error) {
            console.warn(`Failed to load stats for player ${player.id}`, error);
            return player;
        }
    }
    

    calculateFantasyPoints(stats) {
        if (!stats) return 0;
        return (
            (stats.passing?.yards?.value || 0) * 0.04 +
            (stats.passing?.touchdowns?.value || 0) * 4 +
            (stats.rushing?.yards?.value || 0) * 0.1 +
            (stats.rushing?.touchdowns?.value || 0) * 6 +
            (stats.receiving?.receptions?.value || 0) * 1 +
            (stats.receiving?.yards?.value || 0) * 0.1 +
            (stats.receiving?.touchdowns?.value || 0) * 6
        );
    }

    filterPlayers() {
        return this.players.filter(player => {
            const matchesPosition = this.filters.position === 'ALL' || player.position === this.filters.position;
            const matchesTeam = this.filters.team === 'ALL' || player.team === this.filters.team;
            const matchesSearch = player.fullName.toLowerCase().includes(this.filters.search.toLowerCase());

            return matchesPosition && matchesTeam && matchesSearch;
        });
    }

    renderPlayers(sortKey = 'fantasyPoints') {
        const container = document.getElementById('players-container');
        if (!container) return;

        clearElement(container);

        const filteredPlayers = this.filterPlayers();
        const sortedPlayers = sortBy(filteredPlayers, sortKey, true);

        sortedPlayers.forEach(player => {
            const playerCard = this.createPlayerCard(player);
            container.appendChild(playerCard);
        });
    }

    createPlayerCard(player) {
        const card = createElement('div', 'player-card');
        const playerHeadshot = player.headshot || `https://a.espncdn.com/combiner/i?img=/i/headshots/nfl/players/full/${player.id}.png&h=150&w=150&scale=crop`;

        card.innerHTML = `
            <div class="player-header">
                <img src="${playerHeadshot}" alt="${player.fullName}" class="player-image">
                <h3>${player.fullName}</h3>
                <div class="player-position">${player.position}</div>
                <div class="player-team">${player.team}</div>
            </div>
            <div class="player-stats">
                <div class="stat">
                    <label>Fantasy Points</label>
                    <value>${player.fantasyPoints?.toFixed(1)}</value>
                </div>
                ${this.getPositionSpecificStats(player)}
            </div>
            <div class="player-actions">
                <button onclick="playersManager.addToLineup(${player.id})" class="add-to-lineup">Add to Lineup</button>
                <button onclick="playersManager.showPlayerDetails(${player.id})" class="view-details">View Details</button>
            </div>
        `;

        return card;
    }

    getPositionSpecificStats(player) {
        const stats = player.fantasyStats;
        if (!stats) return '';

        switch (player.position) {
            case 'QB':
                return `
                    <div class="stat"><label>Pass Yards</label><value>${stats.passing?.yards?.value || 0}</value></div>
                    <div class="stat"><label>Pass TD</label><value>${stats.passing?.touchdowns?.value || 0}</value></div>`;
            case 'RB':
                return `
                    <div class="stat"><label>Rush Yards</label><value>${stats.rushing?.yards?.value || 0}</value></div>
                    <div class="stat"><label>Rush TD</label><value>${stats.rushing?.touchdowns?.value || 0}</value></div>`;
            case 'WR':
            case 'TE':
                return `
                    <div class="stat"><label>Receptions</label><value>${stats.receiving?.receptions?.value || 0}</value></div>
                    <div class="stat"><label>Rec Yards</label><value>${stats.receiving?.yards?.value || 0}</value></div>`;
            default:
                return '';
        }
    }

    addToLineup(playerId) {
        window.lineupManager.addPlayer(playerId);
    }
}

export default PlayersManager;


--------------------------------------------------------------------------------
FILE: scripts\pages\teams.js
--------------------------------------------------------------------------------
// pages/teams.js
import NFLDataService from '../core/api.js';
import StorageManager from '../core/storage.js';
import { formatters, createElement, clearElement, handleError, sortBy, showLoading, hideLoading, updateFooter } from '../core/utils.js';

class TeamsManager {
    constructor() {
        this.api = new NFLDataService();
        this.storage = new StorageManager();
        this.teams = [];
        this.filters = {
            division: 'ALL',
            conference: 'ALL',
            search: ''
        };
        // this.init(); let main.js do this.
    }

    async init() {
        this.setupEventListeners();
        await this.loadTeams();
    }

    cleanup() {
        // Similar to players.js
        ['conference-filter', 'division-filter', 'sort-options'].forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.replaceWith(element.cloneNode(true));
            }
        });
        if (this.updateInterval) {
            clearInterval(this.updateInterval);
        }
    }

    setupEventListeners() {
        // Search input
        document.getElementById('team-search')?.addEventListener('input', (e) => {
            this.filters.search = e.target.value;
            this.renderTeams();
        });
    
        // Conference filter
        document.getElementById('conference-filter')?.addEventListener('change', (e) => {
            this.filters.conference = e.target.value;
            this.renderTeams();
        });
    
        // Division filter
        document.getElementById('division-filter')?.addEventListener('change', (e) => {
            this.filters.division = e.target.value;
            this.renderTeams();
        });
    
        // Sort options
        document.getElementById('sort-options')?.addEventListener('change', (e) => {
            const sortKey = e.target.value;
            this.renderTeams(sortKey);
        });
    }
    

    async loadTeams() {
        try {
            showLoading();
            const teams = await this.api.getAllTeams();
            this.teams = await this.enhanceTeamsWithStats(teams);
            this.renderTeams();
            updateFooter('Team data loaded successfully');
        } catch (error) {
            handleError(error, 'loadTeams');
            updateFooter(`Error loading teams: ${error.message}`);
        } finally {
            hideLoading();
        }
    }

    async enhanceTeamsWithStats(teams) {
        const currentYear = new Date().getFullYear();
        const seasonType = 2; // Regular season
        // Hardcoded division and conference mapping
        const divisionConferenceMap = {
            "1": { division: "South", conference: "NFC" },
            "2": { division: "East", conference: "AFC" },
            "3": { division: "North", conference: "NFC" },
            "4": { division: "North", conference: "AFC" },
            "5": { division: "North", conference: "AFC" },
            "6": { division: "East", conference: "NFC" },
            "7": { division: "West", conference: "AFC" },
            "8": { division: "North", conference: "NFC" },
            "9": { division: "North", conference: "NFC" },
            "10": { division: "South", conference: "AFC" },
            "11": { division: "South", conference: "AFC" },
            "12": { division: "West", conference: "AFC" },
            "13": { division: "West", conference: "AFC" },
            "14": { division: "West", conference: "NFC" },
            "15": { division: "East", conference: "AFC" },
            "16": { division: "North", conference: "NFC" },
            "17": { division: "East", conference: "AFC" },
            "18": { division: "South", conference: "NFC" },
            "19": { division: "East", conference: "NFC" },
            "20": { division: "East", conference: "AFC" },
            "21": { division: "East", conference: "NFC" },
            "22": { division: "West", conference: "NFC" },
            "23": { division: "North", conference: "AFC" },
            "24": { division: "West", conference: "AFC" },
            "25": { division: "West", conference: "NFC" },
            "26": { division: "West", conference: "NFC" },
            "27": { division: "South", conference: "NFC" },
            "28": { division: "East", conference: "NFC" },
            "29": { division: "South", conference: "NFC" },
            "30": { division: "South", conference: "AFC" },
            "33": { division: "North", conference: "AFC" },
            "34": { division: "South", conference: "AFC" }
        };
        const upcomingGames = await this.api.getUpcomingGames();
        upcomingGames.forEach(game => {
            const homeTeamId = game.homeTeam.id;
            const awayTeamId = game.awayTeam.id;
    
            if (!upcomingGames[homeTeamId]) {
                upcomingGames[homeTeamId] = game;
            }
            if (!upcomingGames[awayTeamId]) {
                upcomingGames[awayTeamId] = game;
            }
        });
    
        return Promise.all(teams.map(async teamData => {
            const team = teamData.team;
            const teamId = team.id;
    
            try {
                // Fetch team betting stats and ATS data
                const [stats, atsDataResponse] = await Promise.all([
                  this.api.getTeamBettingStats(teamId),
                  fetch(`https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2023/types/${seasonType}/teams/${teamId}/ats`),
                ]);
          
                const atsData = await atsDataResponse.json();
          
                // Find the overall ATS record
                const atsOverallItem = atsData?.items?.find(item => item.type?.name === 'atsOverall');
          
                // Extract ATS Record
                const atsWins = atsOverallItem?.wins || 0;
                const atsLosses = atsOverallItem?.losses || 0;
                const atsPushes = atsOverallItem?.pushes || 0;
                console.log('atsWins: ' + atsWins);
                console.log('atsLosses: ' + atsLosses);
                console.log('atsPushes: ' + atsPushes);

                // Fetch the record details from the record endpoint (existing code)
                const recordResponse = await fetch(
                    `https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/${currentYear}/types/${seasonType}/teams/${teamId}/record`
                );
                const recordData = await recordResponse.json();
    
                // Locate the "overall" record
                const overallRecord = recordData.items.find((record) => record.name === 'overall');
    
                // Extract wins, losses, and ties
                const winsStat = overallRecord?.stats.find(stat => stat.name === 'wins');
                const lossesStat = overallRecord?.stats.find(stat => stat.name === 'losses');
                const tiesStat = overallRecord?.stats.find(stat => stat.name === 'ties');
    
                const wins = winsStat?.value || 0;
                const losses = lossesStat?.value || 0;
                const ties = tiesStat?.value || 0;
    
                const totalGames = wins + losses + ties;
                const winPercentage = totalGames > 0 ? wins / totalGames : 0;
    
                // Extract points per game from stats
                const pointsPerGame = stats?.offense?.pointsPerGame?.value || 0;
    
                // Get division and conference
                const division = divisionConferenceMap[teamId]?.division || 'Unknown';
                const conference = divisionConferenceMap[teamId]?.conference || 'Unknown';
    
                // Get the team's upcoming game
                const upcomingGame = upcomingGames[teamId];
    
                // Extract Over/Under value
                const overUnder = upcomingGame ? upcomingGame.overUnder : null;
    
                return {
                    ...teamData,
                    team: {
                    ...team,
                    wins,
                    losses,
                    ties,
                    division,
                    conference,
                    overUnder,
                    atsWins,
                    atsLosses,
                    atsPushes,
                    },
                    winPercentage,
                    pointsPerGame,
                    stats,
                };
            } catch (error) {
                console.warn(`Failed to load stats for team ${team.id}`, error);
                return {
                    ...teamData,
                    team: {
                        ...team,
                        wins: 0,
                        losses: 0,
                        ties: 0,
                        division: divisionConferenceMap[team.id]?.division || 'Unknown',
                        conference: divisionConferenceMap[team.id]?.conference || 'Unknown',
                        overUnder: null,
                    },
                    winPercentage: 0,
                    pointsPerGame: 0,
                    atsWins: 0,
                    atsLosses: 0,
                    atsPushes: 0,
                    stats: {},
                };
            }
        }));
    }
    
    
    

    filterTeams() {
        return this.teams.filter(team => {
            const matchesConference = this.filters.conference === 'ALL' || 
                                      team.team.conference === this.filters.conference;
            const matchesDivision = this.filters.division === 'ALL' || 
                                    team.team.division === this.filters.division;
            const matchesSearch = team.team.name.toLowerCase()
                                    .includes(this.filters.search.toLowerCase());
    
            return matchesConference && matchesDivision && matchesSearch;
        });
    }
    

    renderTeams(sortKey = 'winPercentage') {
        const container = document.getElementById('teams-container');
        if (!container) return;
    
        clearElement(container);
    
        const filteredTeams = this.filterTeams();
    
        const sortedTeams = sortBy(
            filteredTeams,
            (team) => {
                switch (sortKey) {
                    case 'winPercentage':
                        return team.winPercentage;
                    case 'pointsPerGame':
                        return team.pointsPerGame;
                    case 'atsRecord':
                        const atsWins = team.team.atsWins || 0;
                        const atsLosses = team.team.atsLosses || 0;
                        const atsPushes = team.team.atsPushes || 0;
                        const atsTotalGames = atsWins + atsLosses + atsPushes;
                        const atsWinPercentage =
                            atsTotalGames > 0 ? (atsWins + 0.5 * atsPushes) / atsTotalGames : 0;
                        return atsWinPercentage;
                    case 'overUnder':
                        return team.team.overUnder || 0; // Default to 0 if no Over/Under value
                    default:
                        return 0; // Default fallback
                }
            },
            true // Descending order
        );
    
        sortedTeams.forEach((team) => {
            const teamCard = this.createTeamCard(team);
            container.appendChild(teamCard);
        });
    }
    
    
    
    

    createTeamCard(team) {
        const card = createElement('div', 'team-card');
      
        card.innerHTML = `
          <div class="team-header">
            <img src="${team.team.logos?.[0]?.href || 'images/genericLogo.jpg'}" 
                 alt="${team.team.name} logo" 
                 class="team-logo">
            <h3>${team.team.name}</h3>
            <div class="team-record">${this.formatRecord(team)}</div>
          </div>
          <div class="team-stats">
            <div class="stat-column">
              <div class="stat">
                <label>Division</label>
                <value>${team.team.conference} ${team.team.division}</value>
              </div>
              <div class="stat">
                <label>Points Per Game</label>
                <value>${team.pointsPerGame.toFixed(1)}</value>
              </div>
            </div>
            <div class="stat-column">
              <div class="stat">
                <label>ATS Record</label>
                <value>${this.formatAtsRecord(team.team)}</value>
              </div>
              <div class="stat">
                <label>Over/Under</label>
                <value>${team.team.overUnder ? `O/U ${team.team.overUnder}` : 'N/A'}</value>
              </div>
            </div>
          </div>
          <div class="team-actions">
            <button onclick="teamsManager.showTeamSchedule(${team.team.id})" class="view-schedule">
              View Schedule
            </button>
            <button onclick="teamsManager.showTeamDetails(${team.team.id})" class="view-details">
              View Details
            </button>
          </div>
        `;
      
        return card;
      }
    

    formatRecord(team) {
        const wins = team.team.wins || 0;
        const losses = team.team.losses || 0;
        const ties = team.team.ties || 0;
        return `${wins}-${losses}${ties > 0 ? `-${ties}` : ''}`;
    }
    

    formatAtsRecord(team) {
        const wins = team.atsWins || 0;
        const losses = team.atsLosses || 0;
        const pushes = team.atsPushes || 0;
        return `${wins}-${losses}${pushes > 0 ? `-${pushes}` : ''} ATS`;
      }

    formatOverUnder(trends) {
        const overs = trends?.overUnder?.overs?.value || 0;
        const unders = trends?.overUnder?.unders?.value || 0;
        return `O/U: ${overs}-${unders}`;
    }

    renderBettingTrends(trends) {
        if (!trends) return 'No trend data available';

        return `
            <div class="trends-grid">
                <div class="trend">
                    <label>Home</label>
                    <value>${trends.situational?.homeStraightUp?.value || '0-0'}</value>
                </div>
                <div class="trend">
                    <label>Away</label>
                    <value>${trends.situational?.awayStraightUp?.value || '0-0'}</value>
                </div>
                <div class="trend">
                    <label>As Favorite</label>
                    <value>${trends.situational?.asFavorite?.value || '0-0'}</value>
                </div>
                <div class="trend">
                    <label>As Underdog</label>
                    <value>${trends.situational?.asUnderdog?.value || '0-0'}</value>
                </div>
            </div>
        `;
    }

    showTeamSchedule(teamId) {
        window.location.href = `schedule.html?team=${teamId}`;
    }

    showTeamDetails(teamId) {
        window.location.href = `teamCard.html?id=${teamId}`;
    }
}

export default TeamsManager;

--------------------------------------------------------------------------------
FILE: styles\homepage.css
--------------------------------------------------------------------------------
/* homepage.css */

body {
    background: url('../images/fieldBackground.png') no-repeat center center fixed;
    background-size: cover;
}

header {
    background-color: var(--primary-color);
}

.menu {
    background-color: var(--primary-color);
}

.main-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
}

.section {
    width: 100%;
    max-width: 1200px;
    background-color: rgba(255, 255, 255, 0.8);
    padding: 20px;
    border-radius: 10px;
    box-shadow: var(--shadow);
    margin-bottom: 20px;
}

.section h2 {
    color: var(--primary-color);
    text-align: center;
    margin-bottom: 20px;
}

.games-grid,
.teams-grid,
.players-grid,
.insights-grid,
.trends-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 20px;
}

.entry-section {
    background-color: var(--white);
    border-radius: 8px;
    padding: 15px;
    box-shadow: var(--shadow);
    display: flex;
    align-items: center;
}

.entry-logo {
    width: 60px;
    height: auto;
    margin-right: 15px;
}

.entry-name {
    color: var(--primary-color);
    font-weight: bold;
    text-decoration: none;
}

footer {
    background-color: var(--primary-color);
    color: var(--white);
    padding: 10px;
    text-align: center;
}

/* some random stuff so the team logos dont go crazy */

/* Team Card Grid Layout */
.teams-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 20px;
    padding: 20px;
}

/* Team Logo Size Control */
.team-logo {
    width: 80px;  /* Fixed width */
    height: 80px; /* Fixed height */
    object-fit: contain; /* Maintains aspect ratio */
    margin: 10px;
}

/* Team Card Layout */
.team-card {
    background-color: white;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    padding: 15px;
    display: flex;
    flex-direction: column;
    align-items: center;
}

/* Live Game Card Styling */
.game-card {
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    padding: 20px;
    margin-bottom: 15px;
}

.game-teams {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
}

.team-logo {
    width: 60px;
    height: auto;
    object-fit: contain;
}

.team-info-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
    flex: 1;
}

.team-info {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
}

.team-name {
    font-weight: bold;
    font-size: 1em;
    color: var(--primary-color);
}

.team-score {
    font-size: 1.5em;
    font-weight: bold;
}

.vs-section {
    font-size: 1.2em;
    font-weight: bold;
    color: var(--text-color);
    margin: 0 10px;
    align-self: center;
}

.game-status {
    text-align: center;
    font-size: 0.9em;
    color: #666;
    border-top: 1px solid #eee;
    padding-top: 10px;
}


--------------------------------------------------------------------------------
FILE: styles\lineups.css
--------------------------------------------------------------------------------
/* lineups.css */

/* Lineup Builder Section */
.lineup-builder {
    background-color: var(--white);
    padding: 20px;
    border-radius: 8px;
    box-shadow: var(--shadow);
}

.lineup-builder h2 {
    color: var(--primary-color);
    text-align: center;
    margin-bottom: 20px;
}

#lineup-container {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 20px;
    padding: 20px 0;
}

.position-slot {
    background-color: var(--secondary-color);
    padding: 15px;
    border-radius: 8px;
}

.position-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    border-bottom: 2px solid var(--primary-color);
    padding-bottom: 5px;
}

.position-header h4 {
    color: var(--primary-color);
    margin: 0;
}

.max-players {
    font-size: 0.9em;
    color: var(--text-color);
}

.player-slot {
    margin-bottom: 15px;
}

.selected-player {
    display: flex;
    align-items: center;
    background-color: var(--white);
    padding: 10px;
    border-radius: 4px;
}

.player-image {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    margin-right: 10px;
}

.player-info {
    flex-grow: 1;
}

.player-name {
    font-weight: bold;
    color: var(--primary-color);
}

.player-details {
    font-size: 0.9em;
    color: var(--text-color);
}

.player-select {
    width: 100%;
    padding: 5px;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    background-color: var(--white);
}

.lineup-actions {
    display: flex;
    justify-content: center;
    gap: 15px;
    margin-top: 20px;
}

.lineup-actions button {
    padding: 10px 20px;
    border: none;
    border-radius: 4px;
    background-color: var(--primary-color);
    color: white;
    cursor: pointer;
    transition: background-color 0.3s ease;
}

.lineup-actions button:hover {
    background-color: var(--secondary-color);
    color: var(--text-color);
}

#total-projected-points {
    text-align: center;
    font-size: 1.2em;
    font-weight: bold;
    margin-top: 20px;
    color: var(--primary-color);
}

/* Responsive Design */
@media (max-width: 768px) {
    #lineup-container {
        grid-template-columns: 1fr;
    }

    .lineup-actions {
        flex-direction: column;
    }

    .lineup-actions button {
        width: 100%;
    }
}

--------------------------------------------------------------------------------
FILE: styles\main.css
--------------------------------------------------------------------------------
:root {
    --primary-color: #1a1a1a;
    --secondary-color: #9900ff;
    --background-color: #f5f5f5;
    --text-color: #333;
    --border-color: #ddd;
    --success-color: #28a745;
    --warning-color: #ffc107;
    --error-color: #dc3545;
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: Arial, sans-serif;
    line-height: 1.6;
    color: var(--text-color);
    background-color: var(--background-color);
    position: relative;
    min-height: 100vh;
    padding-bottom: 60px; /* Adjust this value based on the footer height */
}

header {
    background-color: var(--primary-color);
    color: white;
    padding: 1rem;
}

footer {
    position: absolute;
    bottom: 0;
    width: 100%;
    height: 60px; /* Adjust this value based on the footer content */
    background-color: var(--primary-color);
    color: var(--white);
    padding: 10px;
    text-align: center;
}

nav ul {
    display: flex;
    list-style: none;
    padding: 1rem 0;
}

nav a {
    color: white;
    text-decoration: none;
    padding: 0.5rem 1rem;
    margin-right: 1rem;
    border-radius: 4px;
    transition: background-color 0.3s;
}

nav a:hover {
    background-color: var(--secondary-color);
}

nav a.current {
    background-color: var(--secondary-color);
}

main {
    padding: 2rem;
    max-width: 1200px;
    margin: 0 auto;
}

.dashboard-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 2rem;
}

.stats-container {
    background: white;
    border-radius: 8px;
    padding: 1rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

/* Responsive Design */
@media (max-width: 768px) {
    nav ul {
        flex-direction: column;
    }

    nav a {
        margin-bottom: 0.5rem;
    }

    .dashboard-grid {
        grid-template-columns: 1fr;
    }
}

--------------------------------------------------------------------------------
FILE: styles\players.css
--------------------------------------------------------------------------------
/* Players Page Specific Styles */
:root {
    --card-width: 280px;
    --card-height: 380px;
    --insight-height: 300px;
}

/* Filters Section */
.filters-section {
    background-color: var(--white);
    padding: 20px;
    border-radius: 8px;
    box-shadow: var(--shadow);
    margin-bottom: 20px;
}

.search-container {
    margin-bottom: 15px;
}

#player-search {
    width: 100%;
    padding: 10px;
    border: 2px solid var(--secondary-color);
    border-radius: 4px;
    font-size: 1em;
}

.filter-controls {
    display: flex;
    gap: 15px;
    flex-wrap: wrap;
}

.filter-controls select {
    flex: 1;
    min-width: 200px;
    padding: 8px;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    background-color: var(--white);
    font-size: 0.9em;
}

/* Players Grid */
.players-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(var(--card-width), 1fr));
    gap: 20px;
    padding: 20px 0;
}

/* Player Card */
.player-card {
    background-color: var(--white);
    border-radius: 8px;
    box-shadow: var(--shadow);
    overflow: hidden;
    transition: transform 0.3s ease;
    height: auto;
    display: flex;
    flex-direction: column;
}

.player-card:hover {
    transform: translateY(-5px);
}

.player-header {
    padding: 15px;
    text-align: center;
    border-bottom: 2px solid var(--secondary-color);
}

.player-image {
    width: 120px;
    height: 120px;
    border-radius: 50%;
    object-fit: cover;
    margin-bottom: 10px;
    border: 3px solid var(--primary-color);
}

.player-name {
    font-size: 1.2em;
    font-weight: bold;
    color: var(--primary-color);
    margin: 5px 0;
}

.player-position,
.player-team {
    font-size: 0.9em;
    color: var(--text-color);
}

.player-stats {
    padding: 15px;
    flex-grow: 1;
}

.stat {
    display: flex;
    justify-content: space-between;
    padding: 5px 0;
    border-bottom: 1px solid var(--border-color);
}

.stat label {
    color: var(--text-color);
    font-weight: bold;
}

.stat value {
    color: var(--primary-color);
}

.player-actions {
    padding: 15px;
    display: flex;
    gap: 10px;
    justify-content: space-around;
    background-color: var(--secondary-color);
}

.player-actions button {
    padding: 8px 15px;
    border: none;
    border-radius: 4px;
    background-color: var(--primary-color);
    color: var(--white);
    cursor: pointer;
    transition: background-color 0.3s ease;
}

.player-actions button:hover {
    background-color: var(--white);
    color: var(--primary-color);
}

/* Fantasy Insights Section */
.fantasy-insights-section {
    background-color: var(--white);
    padding: 20px;
    border-radius: 8px;
    box-shadow: var(--shadow);
    margin-top: 20px;
}

.fantasy-insights-section h2 {
    color: var(--primary-color);
    text-align: center;
    margin-bottom: 20px;
}

.insights-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 20px;
}

.trend-card {
    background-color: var(--secondary-color);
    padding: 15px;
    border-radius: 8px;
    min-height: var(--insight-height);
}

.trend-card h3 {
    color: var(--primary-color);
    text-align: center;
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 2px solid var(--primary-color);
}

.player-list-item {
    display: flex;
    align-items: center;
    padding: 10px;
    background-color: var(--white);
    border-radius: 4px;
    margin-bottom: 10px;
}

.player-list-item:last-child {
    margin-bottom: 0;
}

.player-list-image {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    margin-right: 10px;
}

.player-list-info {
    flex-grow: 1;
}

.player-list-name {
    font-weight: bold;
    color: var(--primary-color);
}

.player-list-detail {
    font-size: 0.9em;
    color: var(--text-color);
}

/* Responsive Design */
@media (max-width: 768px) {
    .filter-controls {
        flex-direction: column;
    }

    .filter-controls select {
        width: 100%;
    }

    .players-grid {
        grid-template-columns: 1fr;
    }

    .player-card {
        height: auto;
        min-height: var(--card-height);
    }

    .insights-grid {
        grid-template-columns: 1fr;
    }

    .trend-card {
        min-height: auto;
    }

    .player-actions {
        flex-direction: column;
    }

    .player-actions button {
        width: 100%;
    }
}

--------------------------------------------------------------------------------
FILE: styles\teams.css
--------------------------------------------------------------------------------
/* Teams Page Specific Styles */
:root {
    --card-width: 300px;
    --card-height: 400px;
    --trend-height: 100px;
}

/* Filters Section */
.filters-section {
    background-color: var(--white);
    padding: 20px;
    border-radius: 8px;
    box-shadow: var(--shadow);
    margin-bottom: 20px;
}

.search-container {
    margin-bottom: 15px;
}

#team-search {
    width: 100%;
    padding: 10px;
    border: 2px solid var(--secondary-color);
    border-radius: 4px;
    font-size: 1em;
}

.filter-controls {
    display: flex;
    gap: 15px;
    flex-wrap: wrap;
}

.filter-controls select {
    flex: 1;
    min-width: 200px;
    padding: 8px;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    background-color: var(--white);
    font-size: 0.9em;
}

/* Teams Grid */
.teams-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(var(--card-width), 1fr));
    gap: 20px;
    padding: 20px 0;
}

/* Team Card */
.team-card {
    background-color: var(--white);
    border-radius: 8px;
    box-shadow: var(--shadow);
    overflow: hidden;
    transition: transform 0.3s ease;
    height: auto;
    display: flex;
    flex-direction: column;
}

.team-card:hover {
    transform: translateY(-5px);
}

.team-header {
    padding: 15px;
    background-color: var(--primary-color);
    color: var(--white);
    text-align: center;
}

.team-logo {
    width: 100px;
    height: 100px;
    object-fit: contain;
    margin-bottom: 10px;
}

.team-stats {
    padding: 15px;
    flex-grow: 1;
}

.stat-column {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.stat {
    display: flex;
    justify-content: space-between;
    padding: 5px 0;
    border-bottom: 1px solid var(--border-color);
}

.stat label {
    color: var(--text-color);
    font-weight: bold;
}

.stat value {
    color: var(--primary-color);
}

.team-trends {
    padding: 15px;
    background-color: var(--secondary-color);
}

.trends-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 10px;
}

.trend {
    text-align: center;
    padding: 5px;
    background-color: var(--white);
    border-radius: 4px;
}

.team-actions {
    padding: 15px;
    display: flex;
    gap: 10px;
    justify-content: space-around;
    background-color: var(--white);
}

.team-actions button {
    padding: 8px 15px;
    border: none;
    border-radius: 4px;
    background-color: var(--primary-color);
    color: var(--white);
    cursor: pointer;
    transition: background-color 0.3s ease;
}

.team-actions button:hover {
    background-color: var(--secondary-color);
    color: var(--text-color);
}

/* Betting Trends Section */
.betting-trends-section {
    background-color: var(--white);
    padding: 20px;
    border-radius: 8px;
    box-shadow: var(--shadow);
    margin-top: 20px;
}

.betting-trends-section h2 {
    color: var(--primary-color);
    text-align: center;
    margin-bottom: 20px;
}

#league-trends {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
}

.trend-card {
    background-color: var(--secondary-color);
    padding: 15px;
    border-radius: 4px;
    text-align: center;
    height: var(--trend-height);
    display: flex;
    flex-direction: column;
    justify-content: center;
}

.trend-value {
    font-size: 1.5em;
    font-weight: bold;
    color: var(--primary-color);
}

.trend-label {
    color: var(--text-color);
    margin-top: 5px;
}

/* Responsive Design */
@media (max-width: 768px) {
    .filter-controls {
        flex-direction: column;
    }

    .filter-controls select {
        width: 100%;
    }

    .teams-grid {
        grid-template-columns: 1fr;
    }

    .team-card {
        height: auto;
        min-height: var(--card-height);
    }

    .trends-grid {
        grid-template-columns: 1fr;
    }

    .team-actions {
        flex-direction: column;
    }

    .team-actions button {
        width: 100%;
    }
}

--------------------------------------------------------------------------------
FILE: testing\apiTester.js
--------------------------------------------------------------------------------
// apiTester.js

class StorageWrapper {
    constructor() {
        this.isNode = typeof window === 'undefined';
        this.storage = this.isNode ? new NodeCache() : {
            set: (key, value, ttl) => {
                const item = {
                    value,
                    expires: Date.now() + (ttl * 1000)
                };
                localStorage.setItem(key, JSON.stringify(item));
            },
            get: (key) => {
                const item = localStorage.getItem(key);
                if (!item) return null;

                const parsed = JSON.parse(item);
                if (Date.now() > parsed.expires) {
                    localStorage.removeItem(key);
                    return null;
                }
                return parsed.value;
            }
        };
    }

    set(key, value, ttl) {
        return this.storage.set(key, value, ttl);
    }

    get(key) {
        return this.storage.get(key);
    }
}

const REQUIRED_API_FIELDS = {
    PLAYER: ['id', 'fullName', 'position'],
    TEAM: ['id', 'name', 'abbreviation'],
    GAME: ['id', 'homeTeam', 'awayTeam', 'startTime'],
    ODDS: ['spread', 'moneyline', 'overUnder']
};

// function validateApiResponse(data, type) {
//     if (!data || typeof data !== 'object') return false;
//     const requiredFields = REQUIRED_API_FIELDS[type];
//     // Allow partial data if some fields are missing
//     return requiredFields.some(field => data.hasOwnProperty(field));
// }

function validateApiResponse(data, type) {
    if (!data) {
        console.warn(`Empty data received for ${type}`);
        return false;
    }

    if (typeof data !== 'object') {
        console.warn(`Invalid data type received for ${type}: ${typeof data}`);
        return false;
    }

    const requiredFields = REQUIRED_API_FIELDS[type];
    const hasFields = requiredFields.some(field => data.hasOwnProperty(field));

    if (!hasFields) {
        // This is a debug message, not an error
        console.debug(`Missing required fields for ${type}:`, requiredFields);
        return false;
    }

    return true;
}

class NFLDataService {
    constructor() {
        this.baseUrls = {
            core: 'https://sports.core.api.espn.com/v2/sports/football/leagues/nfl',
            site: 'https://site.api.espn.com/apis/site/v2/sports/football/nfl'
        };
        this.cache = new StorageWrapper();
        this.requestQueue = [];
        this.rateLimit = {
            requests: 0,
            lastReset: Date.now(),
            maxRequests: 30,  // Adjust based on API limits
            resetInterval: 60000, // 1 minute
            queueDelay: 250 // ms between requests
        };
    }

    async throttleRequest() {
        const now = Date.now();
        if (now - this.rateLimit.lastReset > this.rateLimit.resetInterval) {
            this.rateLimit.requests = 0;
            this.rateLimit.lastReset = now;
            console.log("Rate limit reset");
        }

        if (this.rateLimit.requests >= this.rateLimit.maxRequests) {
            const waitTime = this.rateLimit.resetInterval - (now - this.rateLimit.lastReset);
            console.log(`Rate limit reached, waiting ${waitTime}ms`);
            await new Promise(resolve => setTimeout(resolve, waitTime));
            return this.throttleRequest();
        }

        // Add slightly longer delay between requests to be more respectful to the API
        await new Promise(resolve => setTimeout(resolve, 500)); // 500ms between requests
        this.rateLimit.requests++;
        return true;
    }

    // Functions for gathering current reference IDs for players, teams, games.

    async getAllTeams() {
        const teams = await this.fetchWithCache(`${this.baseUrls.site}/teams`);
        return teams?.sports?.[0]?.leagues?.[0]?.teams || [];
    }

    async getAllActivePlayers() {
        try {
            const teams = await this.getAllTeams();
            if (!teams?.length) {
                throw new Error("No teams retrieved");
            }
            let allPlayers = [];
            let processedTeams = 0;
            let failedTeams = 0;

            for (const teamData of teams) {
                try {
                    // Use the correct endpoint with proper parameters
                    const rosterData = await this.fetchWithCache(
                        `${this.baseUrls.site}/teams/${teamData.team.id}/roster?enable=roster,stats`
                    );

                    if (!this.validateRosterResponse(rosterData)) {
                        console.warn(`Invalid roster data for team ${teamData.team.name}`);
                        failedTeams++;
                        continue;
                    }

                    if (rosterData?.athletes) {
                        // The roster data is organized by position groups (offense, defense, specialTeam)
                        const allPositionGroups = ['offense', 'defense', 'specialTeam'];

                        allPositionGroups.forEach(group => {
                            if (rosterData.athletes.find(g => g.position === group)) {
                                const positionGroup = rosterData.athletes.find(g => g.position === group);
                                const activePlayers = positionGroup.items
                                    .filter(player => player.status?.type === 'active')
                                    .map(player => ({
                                        id: player.id,
                                        fullName: player.fullName,
                                        position: player.position?.abbreviation,
                                        team: teamData.team.name,
                                        jersey: player.jersey,
                                        experience: player.experience,
                                        college: player.college?.name
                                    }));
                                allPlayers = [...allPlayers, ...activePlayers];
                            }
                        });
                    }

                    processedTeams++;
                    console.log(`Successfully processed ${teamData.team.name}: ${allPlayers.length} total active players`);
                } catch (error) {
                    failedTeams++;
                    console.error(`Error processing team ${teamData.team.name}:`, error.message);
                    continue;
                }
            }

            console.log(`Processed ${processedTeams} teams successfully, ${failedTeams} failed`);
            return allPlayers;
        } catch (error) {
            console.error("Error in getAllActivePlayers:", error);
            throw error; // Rethrow to ensure test catches it
        }
    }

    async getCurrentWeekGames() {
        const games = await this.fetchWithCache(`${this.baseUrls.site}/scoreboard`);
        return games?.events || [];
    }

    // Validation Functions

    validateResponse(data, type) {
        if (!validateApiResponse(data, type)) {
            console.warn(`Invalid ${type} data structure received:`, data);
            return false;
        }
        return true;
    }

    validateRosterResponse(data) {
        if (!data || !data.athletes || !Array.isArray(data.athletes)) {
            console.error("Invalid roster data structure:", data);
            return false;
        }
        return true;
    }

    async validateTeamId(teamId) {
        const teams = await this.getAllTeams();
        return teams.some(team => team.team.id === teamId);
    }

    async validatePlayerId(playerId) {
        const players = await this.getAllActivePlayers();
        return players.some(player => player.id === playerId);
    }

    validatePlayerData(data) {
        const required = ['id', 'fullName', 'position'];
        return required.every(field => data?.[field]);
    }

    async validateGameId(gameId) {
        const games = await this.getCurrentWeekGames();
        return games.some(game => game.id === gameId);
    }

    // Fantasy-relevant player stats
    async getPlayerFantasyStats(playerId) {
        const stats = await this.fetchWithCache(
            `${this.baseUrls.core}/seasons/2024/types/2/athletes/${playerId}/statistics`
        );

        return {
            passing: {
                yards: this.extractStat(stats, 'passing', 'passingYards'),
                touchdowns: this.extractStat(stats, 'passing', 'passingTouchdowns'),
                interceptions: this.extractStat(stats, 'passing', 'interceptions')
            },
            rushing: {
                yards: this.extractStat(stats, 'rushing', 'rushingYards'),
                touchdowns: this.extractStat(stats, 'rushing', 'rushingTouchdowns')
            },
            receiving: {
                yards: this.extractStat(stats, 'receiving', 'receivingYards'),
                touchdowns: this.extractStat(stats, 'receiving', 'receivingTouchdowns'),
                receptions: this.extractStat(stats, 'receiving', 'receptions')
            }
        };
    }

    // Betting-relevant team stats
    async getTeamBettingStats(teamId) {
        const stats = await this.fetchWithCache(
            `${this.baseUrls.core}/seasons/2024/types/2/teams/${teamId}/statistics`
        );

        return {
            offense: {
                pointsPerGame: this.extractStat(stats, 'scoring', 'totalPointsPerGame'),
                totalYards: this.extractStat(stats, 'general', 'totalYards'),
                passingYards: this.extractStat(stats, 'passing', 'netPassingYards'),
                rushingYards: this.extractStat(stats, 'rushing', 'rushingYards')
            },
            defense: {
                pointsAllowed: this.extractStat(stats, 'defensive', 'pointsAllowed'),
                sacks: this.extractStat(stats, 'defensive', 'sacks'),
                interceptions: this.extractStat(stats, 'defensiveInterceptions', 'interceptions')
            },
            trends: {
                homeRecord: this.extractStat(stats, 'miscellaneous', 'homeRecord'),
                awayRecord: this.extractStat(stats, 'miscellaneous', 'awayRecord'),
                lastFiveGames: this.extractStat(stats, 'miscellaneous', 'lastFiveGames')
            }
        };
    }

    // Live game data for real-time betting
    async getLiveGameData() {
        return this.fetchWithCache(`${this.baseUrls.site}/scoreboard`);
    }

    // UTILITY FUNCTIONS

    async fetchWithCache(url, expireSeconds = 3600, retries = 3) {
        // Set different cache times based on URL content
        if (expireSeconds === null) {
            if (url.includes('roster')) {
                expireSeconds = 3600; // 1 hour for roster data
            } else if (url.includes('statistics')) {
                expireSeconds = 1800; // 30 minutes for stats
            } else if (url.includes('odds') || url.includes('scores')) {
                expireSeconds = 300; // 5 minutes for live data
            } else {
                expireSeconds = 3600; // Default 1 hour
            }
        }
        for (let i = 0; i < retries; i++) {                    // Retry loop
            try {
                await this.throttleRequest();                   // Rate limiting

                // Works in both Node and browser
                const cachedData = this.cache.get(url);        // Check cache first
                if (cachedData) {
                    return cachedData;
                }

                const response = await fetch(url);              // Make API request
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} for ${url}`);
                }

                const data = await response.json();             // Parse response
                if (!data) {
                    throw new Error(`No data received from ${url}`);
                }

                // Check for error responses from ESPN API
                if (data.error) {
                    throw new Error(`ESPN API error: ${data.error.message || JSON.stringify(data.error)}`);
                }

                // Works in both Node and browser
                this.cache.set(url, data, expireSeconds);      // Store in cache

                return data;

            } catch (error) {
                console.error(`Attempt ${i + 1}/${retries} failed for ${url}:`, error.message);
                if (i === retries - 1) throw error;

                // Exponential backoff
                const waitTime = Math.pow(2, i) * 1000;
                console.log(`Waiting ${waitTime}ms before retry...`);
                await new Promise(resolve => setTimeout(resolve, waitTime));
            }
        }
    }

    extractStat(stats, category, statName, perGame = false) {
        try {
            if (!stats?.splits?.categories) {
                return {
                    value: null,
                    displayValue: "N/A",
                    rank: null
                };
            }
            const categoryStats = stats.splits.categories.find(c => c.name === category);
            if (!categoryStats?.stats) return null;

            const stat = categoryStats.stats.find(s => s.name === statName);
            if (!stat) return null;

            return {
                value: perGame ? stat.value / stats.gamesPlayed : stat.value,
                displayValue: stat.displayValue || String(stat.value),
                rank: stat.rank || null
            };
        } catch (e) {
            console.warn(`Failed to extract ${category}.${statName}:`, e);
            return null;
        }
    }

    extractTeamGameStats(team) {
        return {
            totalYards: team.statistics.find(s => s.name === 'totalYards')?.value,
            passingYards: team.statistics.find(s => s.name === 'netPassingYards')?.value,
            rushingYards: team.statistics.find(s => s.name === 'rushingYards')?.value,
            turnovers: team.statistics.find(s => s.name === 'turnovers')?.value,
            timeOfPossession: team.statistics.find(s => s.name === 'possessionTime')?.value
        };
    }

    extractSpread(event) {
        try {
            const odds = event.competitions[0].odds[0];
            return {
                favorite: odds.details.split(' ')[0],
                line: parseFloat(odds.details.split(' ')[1])
            };
        } catch (e) {
            return null;
        }
    }

    extractOverUnder(event) {
        try {
            return parseFloat(event.competitions[0].odds[0].overUnder);
        } catch (e) {
            return null;
        }
    }

    extractLastNGames(stats, n) {
        try {
            return stats.splits.find(s => s.type === 'lastNGames' && s.value === n)?.stats || null;
        } catch (e) {
            return null;
        }
    }

    // GAME DATA FUNCTIONS

    async getUpcomingGames() {
        const scoreboard = await this.fetchWithCache(`${this.baseUrls.site}/scoreboard`);
        return scoreboard.events.map(event => ({
            id: event.id,
            homeTeam: {
                id: event.competitions[0].competitors[0].id,
                name: event.competitions[0].competitors[0].team.name,
                score: event.competitions[0].competitors[0].score
            },
            awayTeam: {
                id: event.competitions[0].competitors[1].id,
                name: event.competitions[0].competitors[1].team.name,
                score: event.competitions[0].competitors[1].score
            },
            startTime: event.date,
            spread: this.extractSpread(event),
            overUnder: this.extractOverUnder(event),
            status: event.status.type.detail
        }));
    }

    async getGameDetails(gameId) {
        if (!gameId || gameId === 'invalid_game') {
            throw new Error('Invalid game ID provided');
        }

        try {
            const game = await this.fetchWithCache(
                `${this.baseUrls.site}/summary?event=${gameId}`
            );

            if (!game) {
                throw new Error('No game data found');
            }

            return {
                gameInfo: {
                    startTime: game?.header?.timeValid || null,
                    venue: game?.gameInfo?.venue?.fullName || null,
                    attendance: game?.gameInfo?.attendance || 0,
                    weather: game?.gameInfo?.weather || null
                },
                teamStats: {
                    home: game?.boxscore?.teams?.[0] ?
                        this.extractTeamGameStats(game.boxscore.teams[0]) : null,
                    away: game?.boxscore?.teams?.[1] ?
                        this.extractTeamGameStats(game.boxscore.teams[1]) : null
                },
                situation: game?.situation ? {
                    possession: game.situation.possession,
                    down: game.situation.down,
                    distance: game.situation.distance,
                    yardLine: game.situation.yardLine,
                    lastPlay: game.situation.lastPlay?.text
                } : null,
                score: {
                    home: game?.header?.competitions?.[0]?.competitors?.[0]?.score || '0',
                    away: game?.header?.competitions?.[0]?.competitors?.[1]?.score || '0'
                }
            };
        } catch (error) {
            console.error("Error fetching game details:", error);
            throw error; // Rethrow to ensure error test catches it
        }
    }

    // BETTING DATA FUNCTIONS

    async getBettingData(gameId) {
        if (!gameId) throw new Error('Game ID is required');

        try {
            const odds = await this.fetchWithCache(
                `${this.baseUrls.core}/events/${gameId}/competitions/${gameId}/odds`
            );

            // Check if odds data exists
            if (!odds || !odds[0]) {
                return {
                    spread: null,
                    moneyline: null,
                    overUnder: null,
                    movements: []
                };
            }

            const currentOdds = odds[0];

            // Validate the odds data structure
            if (!this.validateResponse(currentOdds, 'ODDS')) {
                console.warn('Invalid odds data structure received');
                return {
                    spread: null,
                    moneyline: null,
                    overUnder: null,
                    movements: []
                };
            }

            return {
                spread: currentOdds.spread ? {
                    favorite: currentOdds.spread.favorite?.abbreviation || null,
                    line: currentOdds.spread.line || null,
                    odds: currentOdds.spread.odds || null
                } : null,
                moneyline: {
                    home: currentOdds.moneyline?.home || null,
                    away: currentOdds.moneyline?.away || null
                },
                overUnder: {
                    total: currentOdds.overUnder || null,
                    overOdds: currentOdds.overOdds || null,
                    underOdds: currentOdds.underOdds || null
                },
                movements: currentOdds.movements?.map(m => ({
                    time: m.timestamp,
                    type: m.type,
                    from: m.from,
                    to: m.to
                })) || []
            };
        } catch (error) {
            console.error("Error fetching betting data:", error);
            return {
                spread: null,
                moneyline: null,
                overUnder: null,
                movements: []
            };
        }
    }

    async getTeamTrends(teamId) {
        const stats = await this.fetchWithCache(
            `${this.baseUrls.core}/seasons/2024/types/2/teams/${teamId}/statistics`
        );

        return {
            overall: {
                wins: this.extractStat(stats, 'record', 'wins'),
                losses: this.extractStat(stats, 'record', 'losses'),
                pointsPerGame: this.extractStat(stats, 'scoring', 'totalPointsPerGame'),
                pointsAllowedPerGame: this.extractStat(stats, 'defensive', 'pointsAllowedPerGame')
            },
            ats: {
                record: this.extractStat(stats, 'betting', 'atsRecord'),
                homeRecord: this.extractStat(stats, 'betting', 'homeAtsRecord'),
                awayRecord: this.extractStat(stats, 'betting', 'awayAtsRecord')
            },
            overUnder: {
                overs: this.extractStat(stats, 'betting', 'oversRecord'),
                unders: this.extractStat(stats, 'betting', 'undersRecord'),
                pushes: this.extractStat(stats, 'betting', 'pushesRecord')
            },
            situational: {
                homeStraightUp: this.extractStat(stats, 'record', 'homeRecord'),
                awayStraightUp: this.extractStat(stats, 'record', 'awayRecord'),
                asFavorite: this.extractStat(stats, 'record', 'favoriteRecord'),
                asUnderdog: this.extractStat(stats, 'record', 'underdogRecord')
            }
        };
    }

    // FANTASY DATA FUNCTIONS

    async getPlayerProjections(playerId) {
        const stats = await this.fetchWithCache(
            `${this.baseUrls.core}/seasons/2024/types/2/athletes/${playerId}/projections`
        );

        return {
            passing: {
                attempts: this.extractStat(stats, 'passing', 'passingAttempts'),
                completions: this.extractStat(stats, 'passing', 'completions'),
                yards: this.extractStat(stats, 'passing', 'passingYards'),
                touchdowns: this.extractStat(stats, 'passing', 'passingTouchdowns'),
                interceptions: this.extractStat(stats, 'passing', 'interceptions')
            },
            rushing: {
                attempts: this.extractStat(stats, 'rushing', 'rushingAttempts'),
                yards: this.extractStat(stats, 'rushing', 'rushingYards'),
                touchdowns: this.extractStat(stats, 'rushing', 'rushingTouchdowns')
            },
            receiving: {
                targets: this.extractStat(stats, 'receiving', 'receivingTargets'),
                receptions: this.extractStat(stats, 'receiving', 'receptions'),
                yards: this.extractStat(stats, 'receiving', 'receivingYards'),
                touchdowns: this.extractStat(stats, 'receiving', 'receivingTouchdowns')
            }
        };
    }

    async getPlayerMatchupStats(playerId, opponentId) {
        const [playerStats, opponentStats] = await Promise.all([
            this.getPlayerStats(playerId),
            this.getTeamDefensiveStats(opponentId)
        ]);

        return {
            player: {
                seasonAverages: {
                    passingYards: this.extractStat(playerStats, 'passing', 'passingYardsPerGame'),
                    rushingYards: this.extractStat(playerStats, 'rushing', 'rushingYardsPerGame'),
                    receivingYards: this.extractStat(playerStats, 'receiving', 'receivingYardsPerGame')
                },
                recentForm: this.extractLastNGames(playerStats, 3)
            },
            opponent: {
                vsPosition: {
                    passingYardsAllowed: this.extractStat(opponentStats, 'defensive', 'passingYardsAllowedPerGame'),
                    rushingYardsAllowed: this.extractStat(opponentStats, 'defensive', 'rushingYardsAllowedPerGame'),
                    receivingYardsAllowed: this.extractStat(opponentStats, 'defensive', 'receivingYardsAllowedPerGame')
                },
                recentDefense: this.extractLastNGames(opponentStats, 3)
            }
        };
    }

    // For moneyline/spread predictions
    async getTeamPerformanceMetrics(teamId) {
        const stats = await this.fetchWithCache(
            `${this.baseUrls.core}/seasons/2024/types/2/teams/${teamId}/statistics`
        );

        return {
            offense: {
                pointsPerGame: this.extractStat(stats, 'scoring', 'totalPointsPerGame'),
                yardsPerGame: this.extractStat(stats, 'passing', 'yardsPerGame'),
                thirdDownConvPct: this.extractStat(stats, 'miscellaneous', 'thirdDownConvPct'),
                redZoneEfficiency: this.extractStat(stats, 'miscellaneous', 'redzoneScoringPct')
            },
            defense: {
                pointsAllowedPerGame: this.extractStat(stats, 'defensive', 'pointsAllowed'),
                yardsAllowedPerGame: this.extractStat(stats, 'defensive', 'yardsAllowed'),
                sacks: this.extractStat(stats, 'defensive', 'sacks'),
                takeaways: this.extractStat(stats, 'miscellaneous', 'totalTakeaways')
            }
        };
    }

    // For player props
    async getPlayerPropMetrics(playerId) {
        const stats = await this.fetchWithCache(
            `${this.baseUrls.core}/seasons/2024/types/2/athletes/${playerId}/statistics`
        );

        return {
            passing: {
                yardsPerGame: this.extractStat(stats, 'passing', 'passingYardsPerGame'),
                completionPct: this.extractStat(stats, 'passing', 'completionPct'),
                attemptsPerGame: this.extractStat(stats, 'passing', 'passingAttempts', true),
                yardsPerAttempt: this.extractStat(stats, 'passing', 'yardsPerPassAttempt')
            },
            rushing: {
                yardsPerGame: this.extractStat(stats, 'rushing', 'rushingYardsPerGame'),
                attemptsPerGame: this.extractStat(stats, 'rushing', 'rushingAttempts', true),
                yardsPerCarry: this.extractStat(stats, 'rushing', 'yardsPerRushAttempt')
            },
            receiving: {
                yardsPerGame: this.extractStat(stats, 'receiving', 'receivingYardsPerGame'),
                receptionsPerGame: this.extractStat(stats, 'receiving', 'receptions', true),
                yardsPerReception: this.extractStat(stats, 'receiving', 'yardsPerReception'),
                targetShare: this.extractStat(stats, 'receiving', 'receivingTargets', true)
            }
        };
    }

    // For over/under predictions
    async getGameScoringFactors(homeTeamId, awayTeamId) {
        const [homeStats, awayStats] = await Promise.all([
            this.getTeamPerformanceMetrics(homeTeamId),
            this.getTeamPerformanceMetrics(awayTeamId)
        ]);

        return {
            homeTeam: {
                averagePointsFor: homeStats.offense.pointsPerGame,
                averagePointsAgainst: homeStats.defense.pointsAllowedPerGame,
                offensiveEfficiency: homeStats.offense.redZoneEfficiency,
                defensiveEfficiency: homeStats.defense.takeaways
            },
            awayTeam: {
                averagePointsFor: awayStats.offense.pointsPerGame,
                averagePointsAgainst: awayStats.defense.pointsAllowedPerGame,
                offensiveEfficiency: awayStats.offense.redZoneEfficiency,
                defensiveEfficiency: awayStats.defense.takeaways
            }
        };
    }

    // For live betting updates
    async getLiveGameStats(gameId) {
        const game = await this.fetchWithCache(
            `${this.baseUrls.site}/scoreboard/events/${gameId}`,
            30 // shorter cache time for live data
        );

        return {
            score: {
                home: game.homeTeam.score,
                away: game.awayTeam.score
            },
            timeRemaining: game.status.displayClock,
            quarter: game.status.period,
            possession: game.situation.possession,
            lastPlay: game.situation.lastPlay,
            momentum: {
                yardsLastDrive: game.drives.current.yards,
                timeOfPossession: game.drives.current.timeOfPossession
            }
        };
    }


}



// async function testNFLDataService() {
//     const nflData = new NFLDataService();

//     // Test with known players
//     const players = {
//         mahomes: "3139477",
//         mccaffrey: "3916387",
//         herbert: "4362649"
//     };

//     for (const [name, id] of Object.entries(players)) {
//         console.log(`Testing ${name} stats:`);
//         const stats = await nflData.getPlayerFantasyStats(id);
//         console.log(JSON.stringify(stats, null, 2));
//     }
// }

async function testNFLDataService() {
    const nflData = new NFLDataService();

    console.log("\n=== TESTING ID VALIDATION ===\n");

    // Get and display all valid teams
    const teams = await nflData.getAllTeams();
    console.log("Valid Teams:");
    teams.forEach(team => {
        console.log(`${team.team.displayName}: ${team.team.id}`);
    });

    // Get and display active players (could be limited to top players)
    const players = await nflData.getAllActivePlayers();
    console.log("\nSample Active Players:");
    players.slice(0, 10).forEach(player => {
        console.log(`${player.fullName}: ${player.id}`);
    });

    // Get current games
    const currentGames = await nflData.getCurrentWeekGames();
    console.log("\nCurrent Week Games:");
    currentGames.forEach(game => {
        console.log(`${game.name}: ${game.id}`);
    });

    // Known test IDs
    const testData = {
        players: {
            mahomes: "3139477",    // QB
            mccaffrey: "3916387",  // RB
            Jaylen: "4567534",   // WR
        },
        teams: {
            chiefs: "12",
            niners: "25",
            vikings: "16",
        },
        // Use a recent or upcoming game ID
        gameId: "401671813"
    };

    console.log("\n=== NFLDataService Comprehensive Test Results ===\n");

    try {
        // 1. Test Player Fantasy Stats
        console.log("1. TESTING PLAYER FANTASY STATS");
        console.log("--------------------------------");
        for (const [name, id] of Object.entries(testData.players)) {
            console.log(`\nTesting ${name.toUpperCase()} (ID: ${id}) fantasy stats:`);
            const stats = await nflData.getPlayerFantasyStats(id);
            console.log(JSON.stringify(stats, null, 2));
        }

        // 2. Test Team Betting Stats
        console.log("\n\n2. TESTING TEAM BETTING STATS");
        console.log("--------------------------------");
        for (const [name, id] of Object.entries(testData.teams)) {
            console.log(`\nTesting ${name.toUpperCase()} (ID: ${id}) betting stats:`);
            const stats = await nflData.getTeamBettingStats(id);
            console.log(JSON.stringify(stats, null, 2));
        }

        // 3. Test Live Game Data
        console.log("\n\n3. TESTING LIVE GAME DATA");
        console.log("--------------------------------");
        const liveData = await nflData.getLiveGameData();
        console.log(JSON.stringify(liveData, null, 2));

        // 4. Test Upcoming Games
        console.log("\n\n4. TESTING UPCOMING GAMES");
        console.log("--------------------------------");
        const upcomingGames = await nflData.getUpcomingGames();
        console.log(JSON.stringify(upcomingGames, null, 2));

        // 5. Test Game Details
        console.log("\n\n5. TESTING GAME DETAILS");
        console.log("--------------------------------");
        const gameDetails = await nflData.getGameDetails(testData.gameId);
        console.log(JSON.stringify(gameDetails, null, 2));

        // 6. Test Betting Data
        console.log("\n\n6. TESTING BETTING DATA");
        console.log("--------------------------------");
        const bettingData = await nflData.getBettingData(testData.gameId);
        console.log(JSON.stringify(bettingData, null, 2));

        // 7. Test Team Trends
        console.log("\n\n7. TESTING TEAM TRENDS");
        console.log("--------------------------------");
        const teamTrends = await nflData.getTeamTrends(testData.teams.chiefs);
        console.log(JSON.stringify(teamTrends, null, 2));

        // 8. Test Player Projections
        console.log("\n\n8. TESTING PLAYER PROJECTIONS");
        console.log("--------------------------------");
        const projections = await nflData.getPlayerProjections(testData.players.mahomes);
        console.log(JSON.stringify(projections, null, 2));

        // 9. Test Player Matchup Stats
        console.log("\n\n9. TESTING PLAYER MATCHUP STATS");
        console.log("--------------------------------");
        const matchupStats = await nflData.getPlayerMatchupStats(
            testData.players.mahomes,
            testData.teams.niners
        );
        console.log(JSON.stringify(matchupStats, null, 2));

        // 10. Test Team Performance Metrics
        console.log("\n\n10. TESTING TEAM PERFORMANCE METRICS");
        console.log("--------------------------------");
        const performanceMetrics = await nflData.getTeamPerformanceMetrics(testData.teams.chiefs);
        console.log(JSON.stringify(performanceMetrics, null, 2));

        // 11. Test Player Prop Metrics
        console.log("\n\n11. TESTING PLAYER PROP METRICS");
        console.log("--------------------------------");
        const propMetrics = await nflData.getPlayerPropMetrics(testData.players.mahomes);
        console.log(JSON.stringify(propMetrics, null, 2));

        // 12. Test Game Scoring Factors
        console.log("\n\n12. TESTING GAME SCORING FACTORS");
        console.log("--------------------------------");
        const scoringFactors = await nflData.getGameScoringFactors(
            testData.teams.chiefs,
            testData.teams.niners
        );
        console.log(JSON.stringify(scoringFactors, null, 2));

        // 13. Test Live Game Stats
        console.log("\n\n13. TESTING LIVE GAME STATS");
        console.log("--------------------------------");
        const liveGameStats = await nflData.getLiveGameStats(testData.gameId);
        console.log(JSON.stringify(liveGameStats, null, 2));

    } catch (error) {
        console.error("\n❌ ERROR IN TESTING:");
        console.error(error);
    }

    console.log("\n=== Test Complete ===");
}

class NFLBettingPredictor {
    predictSpread(homeTeam, awayTeam) {
        // Implement prediction algorithm using team stats
    }

    predictOverUnder(homeTeam, awayTeam) {
        // Implement O/U prediction using scoring trends
    }

    predictPropBets(playerId, opponent) {
        // Implement player prop predictions
    }
}

class NodeCache {
    constructor() {
        this.cache = new Map();
    }

    set(key, value, ttl) {
        const expires = Date.now() + (ttl * 1000);
        this.cache.set(key, { value, expires });
    }

    get(key) {
        const data = this.cache.get(key);
        if (!data) return null;
        if (Date.now() > data.expires) {
            this.cache.delete(key);
            return null;
        }
        return data.value;
    }
}


// class NFLDataCache {
//     static set(key, data, ttl = 300) {
//         const item = {
//             data,
//             expires: Date.now() + (ttl * 1000)
//         };
//         localStorage.setItem(key, JSON.stringify(item));
//     }

//     static get(key) {
//         const item = localStorage.getItem(key);
//         if (!item) return null;

//         const parsed = JSON.parse(item);
//         if (Date.now() > parsed.expires) {
//             localStorage.removeItem(key);
//             return null;
//         }
//         return parsed.data;
//     }
// }


class NFLDataServiceTester {
    constructor() {
        this.nflData = new NFLDataService();
        this.testData = {
            players: {
                mahomes: "3139477",    // QB
                mccaffrey: "3916387",  // RB
                jefferson: "4262921",   // WR
            },
            teams: {
                chiefs: "12",
                niners: "25",
                vikings: "16",
            },
            games: {
                upcoming: "401671813",  // Update with current game
                live: "401671665",      // Update with live game
                completed: "401547665"  // Update with completed game
            }
        };
    }

    async runAllTests() {
        console.log("\n=== Running All Tests ===\n");
        await this.testPlayerData();
        await this.testTeamData();
        await this.testGameData();
        await this.testBettingData();
        console.log("\n=== All Tests Complete ===\n");
    }

    // async testPlayerData() {
    //     console.log("\n--- Testing Player Data ---\n");

    //     try {
    //         // Test player list retrieval
    //         console.log("Testing getAllActivePlayers():");
    //         const players = await this.nflData.getAllActivePlayers();
    //         console.log(`Retrieved ${players.length} players`);
    //         console.log("Sample player:", players[0]);

    //         // Test individual player stats
    //         console.log("\nTesting individual player stats:");
    //         for (const [name, id] of Object.entries(this.testData.players)) {
    //             console.log(`\nTesting ${name} (ID: ${id}):`);
    //             const stats = await this.nflData.getPlayerFantasyStats(id);
    //             console.log(JSON.stringify(stats, null, 2));
    //         }
    //     } catch (error) {
    //         console.error("❌ Player Data Test Error:", error);
    //     }
    // }

    async testPlayerData() {
        console.log("\n--- Testing Player Data ---\n");

        try {
            // Test player list retrieval
            console.log("Testing getAllActivePlayers():");
            const players = await this.nflData.getAllActivePlayers();

            // Group players by team for better debugging
            const teamCounts = {};
            players.forEach(p => {
                teamCounts[p.team] = (teamCounts[p.team] || 0) + 1;
            });

            // Print some other shit
            console.log(`Retrieved ${players.length} total players:`);
            Object.entries(teamCounts).forEach(([team, count]) => {
                console.log(`  ${team}: ${count} players`);
            });

            // Print the OG shit
            console.log(`Retrieved ${players.length} players from ${players.reduce((acc, p) => acc.add(p.team), new Set()).size} teams`);
            if (players.length > 0) {
                console.log("Sample player:", JSON.stringify(players[0], null, 2));
            } else {
                console.error("❌ No players retrieved - possible API or parsing error");
            }

            // Test individual player stats
            console.log("\nTesting individual player stats:");
            for (const [name, id] of Object.entries(this.testData.players)) {
                try {
                    console.log(`\nTesting ${name} (ID: ${id}):`);
                    const stats = await this.nflData.getPlayerFantasyStats(id);
                    console.log(JSON.stringify(stats, null, 2));
                } catch (statError) {
                    console.error(`❌ Error getting stats for ${name}:`, statError.message);
                }
            }
        } catch (error) {
            console.error("❌ Player Data Test Error:", error.message);
            // Log additional error details for debugging
            console.error("Error details:", {
                name: error.name,
                message: error.message,
                stack: error.stack
            });
            // Log the full error stack for debugging
            // console.error(error.stack);
        }
    }

    async testTeamData() {
        console.log("\n--- Testing Team Data ---\n");

        try {
            // Test team list retrieval
            console.log("Testing getAllTeams():");
            const teams = await this.nflData.getAllTeams();
            console.log(`Retrieved ${teams.length} teams`);

            // Test individual team stats
            console.log("\nTesting individual team stats:");
            for (const [name, id] of Object.entries(this.testData.teams)) {
                console.log(`\nTesting ${name} (ID: ${id}):`);
                const stats = await this.nflData.getTeamBettingStats(id);
                console.log(JSON.stringify(stats, null, 2));
            }
        } catch (error) {
            console.error("❌ Team Data Test Error:", error);
        }
    }

    async testGameData() {
        console.log("\n--- Testing Game Data ---\n");

        try {
            // Test upcoming games
            console.log("Testing getUpcomingGames():");
            const games = await this.nflData.getUpcomingGames();
            console.log(`Retrieved ${games.length} upcoming games`);
            console.log("First game:", JSON.stringify(games[0], null, 2));

            // Test specific game details
            console.log("\nTesting getGameDetails():");
            for (const [type, id] of Object.entries(this.testData.games)) {
                console.log(`\nTesting ${type} game (ID: ${id}):`);
                const details = await this.nflData.getGameDetails(id);
                console.log(JSON.stringify(details, null, 2));
            }
        } catch (error) {
            console.error("❌ Game Data Test Error:", error);
        }
    }

    async testBettingData() {
        console.log("\n--- Testing Betting Data ---\n");

        try {
            // Test betting data for upcoming game
            console.log("Testing getBettingData():");
            const betting = await this.nflData.getBettingData(this.testData.games.upcoming);
            console.log(JSON.stringify(betting, null, 2));

            // Test team trends
            console.log("\nTesting getTeamTrends():");
            const trends = await this.nflData.getTeamTrends(this.testData.teams.chiefs);
            console.log(JSON.stringify(trends, null, 2));
        } catch (error) {
            console.error("❌ Betting Data Test Error:", error);
        }
    }

    // Utility method to run a single test
    async runTest(testName) {
        if (this[testName]) {
            console.log(`\n=== Running ${testName} ===\n`);
            await this[testName]();
            console.log(`\n=== ${testName} Complete ===\n`);
        } else {
            console.error(`Test "${testName}" not found`);
        }
    }

    async testSpecificEndpoints() {
        // Test known good team/player IDs
        const knownTeam = await this.nflData.getTeamBettingStats('12'); // Chiefs
        const knownPlayer = await this.nflData.getPlayerFantasyStats('3139477'); // Mahomes
        console.log({ knownTeam, knownPlayer });
    }

    // async testErrorCases() {
    //     try {
    //         await this.nflData.getPlayerFantasyStats('invalid_id');
    //     } catch (error) {
    //         console.log('Expected error caught:', error.message);
    //     }
    // }

    // async testConcurrentRequests() {
    //     const promises = [
    //         this.nflData.getUpcomingGames(),
    //         this.nflData.getTeamBettingStats('12'),
    //         this.nflData.getPlayerFantasyStats('3139477')
    //     ];
    //     const results = await Promise.allSettled(promises);
    //     console.log('Concurrent results:', results);
    // }

    // async testDataConsistency() {
    //     const player = await this.nflData.getPlayerFantasyStats('3139477');
    //     const team = await this.nflData.getTeamBettingStats('12');
    //     // Verify player stats match team totals where applicable
    //     console.log('Data consistency check:', {player, team});
    // }

    async testCaching() {
        // Test that subsequent calls use cached data
        console.log("Testing cache hits...");
        const start = Date.now();
        const firstCall = await this.nflData.getTeamBettingStats(this.testData.teams.chiefs);
        const firstTime = Date.now() - start;

        const secondStart = Date.now();
        const secondCall = await this.nflData.getTeamBettingStats(this.testData.teams.chiefs);
        const secondTime = Date.now() - secondStart;

        console.log(`First call time: ${firstTime}ms`);
        console.log(`Second call time: ${secondTime}ms`);
        console.log(`Cache working: ${secondTime < firstTime}`);
    }

    async testCoreEndpoints() {
        const endpoints = [
            { name: 'Player Stats', fn: () => this.nflData.getPlayerFantasyStats(this.testData.players.mahomes) },
            { name: 'Team Stats', fn: () => this.nflData.getTeamBettingStats(this.testData.teams.chiefs) },
            { name: 'Game Data', fn: () => this.nflData.getGameDetails(this.testData.games.upcoming) },
            { name: 'Betting Data', fn: () => this.nflData.getBettingData(this.testData.games.upcoming) }
        ];

        for (const endpoint of endpoints) {
            try {
                console.log(`Testing ${endpoint.name}...`);
                const data = await endpoint.fn();
                console.log(`✓ ${endpoint.name} success:`, data ? 'Data received' : 'No data');
            } catch (error) {
                console.error(`✗ ${endpoint.name} failed:`, error.message);
            }
        }
    }

    async testErrorCases() {
        const errorTests = [
            {
                name: 'Invalid Player ID',
                fn: () => this.nflData.getPlayerFantasyStats('invalid_id'),
                expectedError: 'HTTP error! status: 404'
            },
            {
                name: 'Invalid Team ID',
                fn: () => this.nflData.getTeamBettingStats('999'),
                expectedError: 'HTTP error! status: 404'
            },
            {
                name: 'Invalid Game ID',
                fn: () => this.nflData.getGameDetails('invalid_game'),
                expectedError: 'Invalid game ID provided'
            },
            {
                name: 'Missing Required Fields',
                fn: () => {
                    const result = this.nflData.validateResponse({}, 'PLAYER');
                    if (result === true) {
                        throw new Error('Validation should have failed');
                    }
                },
                expectedError: 'Validation should have failed'
            }
        ];

        for (const test of errorTests) {
            try {
                await test.fn();
                console.log(`✗ ${test.name} should have failed but didn't`);
            } catch (error) {
                if (error.message.includes(test.expectedError) || test.name === 'Missing Required Fields') {
                    console.log(`✓ ${test.name} failed as expected:`, error.message);
                } else {
                    console.log(`✗ ${test.name} failed with unexpected error:`, error.message);
                }
            }
        }
    }

    async testConcurrentRequests() {
        const requests = [
            this.nflData.getPlayerFantasyStats(this.testData.players.mahomes),
            this.nflData.getTeamBettingStats(this.testData.teams.chiefs),
            this.nflData.getGameDetails(this.testData.games.upcoming),
            this.nflData.getBettingData(this.testData.games.upcoming)
        ];

        const results = await Promise.allSettled(requests);
        console.log('Concurrent requests results:',
            results.map(r => r.status === 'fulfilled' ? '✓ Success' : `✗ Failed: ${r.reason}`));
    }

    async testDataConsistency() {
        // Get player and team stats
        const playerStats = await this.nflData.getPlayerFantasyStats(this.testData.players.mahomes);
        const teamStats = await this.nflData.getTeamBettingStats(this.testData.teams.chiefs);

        // Compare relevant data
        console.log('Player passing yards:', playerStats?.passing?.yards?.value);
        console.log('Team passing yards:', teamStats?.offense?.passingYards?.value);

        // Basic consistency check
        if (playerStats?.passing?.yards?.value && teamStats?.offense?.passingYards?.value) {
            // Player yards should be less than or equal to team yards
            const isConsistent = playerStats.passing.yards.value >= 0 &&
                teamStats.offense.passingYards.value >= 0;
            console.log('Data consistency check:',
                isConsistent ? '✓ Consistent' : '✗ Inconsistent');
        }
    }
}

async function runComprehensiveTests() {
    const tester = new NFLDataServiceTester();

    console.log("\n=== Running Comprehensive Tests ===\n");

    // 1. Cache Testing
    console.log("1. Testing Cache Functionality");
    await tester.testCaching();

    // 2. API Endpoint Testing
    console.log("\n2. Testing Core API Endpoints");
    await tester.testCoreEndpoints();

    // 3. Error Handling
    console.log("\n3. Testing Error Handling");
    await tester.testErrorCases();

    // 4. Concurrent Requests
    console.log("\n4. Testing Concurrent Requests");
    await tester.testConcurrentRequests();

    // 5. Data Consistency
    console.log("\n5. Testing Data Consistency");
    await tester.testDataConsistency();

    // 6. just do it all again lol
    await tester.runAllTests();
}

// Example usage:
const tester = new NFLDataServiceTester();

// Run all tests
//tester.runAllTests();

// Or run specific tests
async function runSpecificTests() {
    // await tester.runTest('testPlayerData');
    // await tester.runTest('testTeamData');
    // await tester.runTest('testGameData');
    // await tester.runTest('testBettingData');
}

//runSpecificTests().catch(console.error);

//testNFLDataService();


runComprehensiveTests().catch(console.error);

--------------------------------------------------------------------------------
FILE: testing\espn-api-list.md
--------------------------------------------------------------------------------
# List of NFL API Endpoints

This page has been updated a lot in the past 3 years. **Older revisions you might like more than this one:**

- [**June 2021**](https://gist.github.com/nntrn/ee26cb2a0716de0947a0a4e9a157bc1c/b99b9e0d2df72470fa622e2f76cecb0362111e9a) - list of endpoints for other sports/leagues (i.e. basketball, baseball, lacrosse, rugby)
- [**August 2021**](https://gist.github.com/nntrn/ee26cb2a0716de0947a0a4e9a157bc1c/9daed3db02cc2661e63ea08741c6053c5aef28ce#league-history---get-all-historical-data) - get historical fantasy league data
- [**September 2021**](https://gist.github.com/nntrn/ee26cb2a0716de0947a0a4e9a157bc1c/2fa98612cedcbad033d4206b16cd360c9b654ae9#file-source-txt) - list of endpoints in plain text
- [**May 2023**](https://gist.github.com/nntrn/ee26cb2a0716de0947a0a4e9a157bc1c/cd7462cd365e516d7499b43f027db4b8b1a2d6c0) - collapsed endpoint response examples

<br><strong>Additional Resources</strong>

- [nfl-nerd](https://github.com/nntrn/nfl-nerd) ([api](https://raw.githubusercontent.com/nntrn/nfl-nerd/master/src/api.js))
- [espn-wiki](https://github.com/nntrn/espn-wiki/wiki) :star:
- [ESPN's hidden API endpoints](https://gist.github.com/akeaswaran/b48b02f1c94f873c6655e7129910fc3b)
- [Using ESPN's new Fantasy API (v3)](https://stmorse.github.io/journal/espn-fantasy-v3.html)
- [ESPN: Get Endpoint (CRAN Package)](https://cran.r-project.org/web/packages/ffscrapr/vignettes/espn_getendpoint.html)

<br><strong>Notes</strong>

- This page is limited to NFL endpoints but can be refashioned for other leagues (i.e. `/sports/football/leagues/nfl/` => `/sports/baseball/leagues/mlb/`)
  
  **List of ESPN leagues**: [API](https://sports.core.api.espn.com/v2/sports) | [Document](https://gist.githubusercontent.com/nntrn/ee26cb2a0716de0947a0a4e9a157bc1c/raw/5e0b844e4d56d0b049747024a04bb7949c2d6c5d/extending-espn-api.md)

<br><strong>Paramaters</strong>

- **{YEAR}**: Football season (`YYYY`)
- **{SEASONTYPE}**: 1=pre, 2=regular, 3=post, 4=off
- **{EVENT_ID}**: game id
- **{TEAM_ID}**: 1-32 ([view all](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/teams))
- **{ATHLETE_ID}**: [view all](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/athletes?limit=1000&active=true)
- **{FANTASY_LEAGUE_ID}**: Fantasy league id
- **{BET_PROVIDER_ID}**: [view all](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/providers?limit=100)

<div id="toc"></div>

## Table of Contents

- [Game Night](#game-night)
- [Reference List](#reference-list)
- [News](#news)
- [Detailed](#detailed)
- [Odds](#odds)
- [Teams](#teams)
- [Games](#games)
- [Athletes](#athletes)
- [Calendar](#calendar)
- [Scoreboard](#scoreboard)
- [Leagues](#leagues)
- [Search](#search)
- [Pick em challenges](#pick-em-challenges)
- [Fantasy](#fantasy)
- [REST API Response Examples](#rest-api-response-examples)



## Game Night

* **Get all Monday games**:  
  https://site.api.espn.com/apis/site/v2/mondaynightfootball
  
* **Get all Thursday games**:  
  https://site.api.espn.com/apis/site/v2/thursdaynightfootball

* **Get all Sunday games**:  
  https://site.api.espn.com/apis/site/v2/sundaynightfootball


## Reference List

Get list of ids

- **Events**:  
  [site.api.espn.com/apis/site/v2/sports/football/nfl/**scoreboard**?limit=1000&dates=**{YEAR}**](https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard?limit=1000&dates=2023)

  Filter: [&seasontype=2&week=1](https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard?dates=2023&seasontype=2&week=1) | [&seasontype=2](https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard?limit=1000&dates=2021&seasontype=2)

- **Athletes**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/**athletes**?limit=1000&active=true](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/athletes?limit=1000&active=true)

- **Team (list of IDs)**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/**teams**?limit=32](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/teams?limit=32)

- **Positions**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/**positions**?limit=75](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/positions?limit=75)

- **Venues**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/**venues**?limit=700](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/venues?limit=700)

- **Leaders**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/**leaders**?limit=100](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/leaders?limit=100)

- **Seasons**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/**seasons**?limit=100](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons?limit=100)

- **Franchises**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/**franchises**?limit=50](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/franchises?limit=50)

- **News**:  
  [site.api.espn.com/apis/site/v2/sports/football/nfl/**news**?limit=50](https://site.api.espn.com/apis/site/v2/sports/football/nfl/news?limit=50)

- **Team News** (limit is incompatible with team filter):  
  [site.api.espn.com/apis/site/v2/sports/football/nfl/**news**?team=**{TEAM_ID}**](https://site.api.espn.com/apis/site/v2/sports/football/nfl/news?team=10)


## News

- **NFL news**  
  [site.api.espn.com/apis/site/v2/sports/football/nfl/**news**?limit=50](https://site.api.espn.com/apis/site/v2/sports/football/nfl/news?limit=50)

- :star: **news with api links to event**  
  [now.core.api.espn.com/v1/sports/news?limit=1000&sport=football](https://now.core.api.espn.com/v1/sports/news?limit=1000&sport=football)

- :star: **Searchable by playerId:**  
  [site.api.espn.com/apis/fantasy/v2/games/ffl/news/players?limit=50&playerId=**{ATHLETE_ID}**](https://site.api.espn.com/apis/fantasy/v2/games/ffl/news/players?limit=50&playerId=2977187)
  **Usage example**: [one](https://gist.github.com/nntrn/ee26cb2a0716de0947a0a4e9a157bc1c?permalink_comment_id=5200643#gistcomment-5200643)

- **Search query**: (max limit 100)   
  [site.web.api.espn.com/apis/search/v2?limit=100&query=**{SEARCH_TERM}**](https://site.web.api.espn.com/apis/search/v2?query=kupp&limit=100)  
  **Usage example**: [two](https://gist.github.com/nntrn/ee26cb2a0716de0947a0a4e9a157bc1c?permalink_comment_id=5200298#gistcomment-5200298)

- **Team news**:   
  [site.api.espn.com/apis/site/v2/sports/football/nfl/**news**?team=**{TEAM_ID}**](https://site.api.espn.com/apis/site/v2/sports/football/nfl/news?team=10)
  
## Detailed

Get live updates (xhr=1)

- **Scoreboard**: [cdn.espn.com/core/nfl/scoreboard?xhr=1&limit=50](https://cdn.espn.com/core/nfl/scoreboard?xhr=1&limit=50)

- **Schedule**: [cdn.espn.com/core/nfl/schedule?xhr=1&year=**{YEAR}**&week=**{WEEK_NUM}**](https://cdn.espn.com/core/nfl/schedule?xhr=1&year=2020&week=2)

- **Standings**: [cdn.espn.com/core/nfl/standings?xhr=1](https://cdn.espn.com/core/nfl/standings?xhr=1)

- **Boxscore**: [cdn.espn.com/core/nfl/boxscore?xhr=1&gameId=**{EVENT_ID}**](https://cdn.espn.com/core/nfl/boxscore?xhr=1&gameId=401220225)

- **Recap**: [cdn.espn.com/core/nfl/recap?xhr=1&gameId=**{EVENT_ID}**](https://cdn.espn.com/core/nfl/recap?xhr=1&gameId=401220225)

- **Plays**: [cdn.espn.com/core/nfl/playbyplay?xhr=1&gameId=**{EVENT_ID}**](https://cdn.espn.com/core/nfl/playbyplay?xhr=1&gameId=401220225)

- **Game**: [cdn.espn.com/core/nfl/game?xhr=1&gameId=**{EVENT_ID}**](https://cdn.espn.com/core/nfl/game?xhr=1&gameId=401127922)

- **Matchup**: [cdn.espn.com/core/nfl/matchup?xhr=1&gameId=**{EVENT_ID}**](https://cdn.espn.com/core/nfl/matchup?xhr=1&gameId=401220225)

## Odds

- **Win probabilities**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/**{EVENT_ID}**/competitions/**{EVENT_ID}**/probabilities?limit=200](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401249063/competitions/401249063/probabilities?limit=200)

- **Odds**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/**{EVENT_ID}**/competitions/**{EVENT_ID}**/odds](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401249063/competitions/401249063/odds)

- **Matchup Quality & Game Projection**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/**{EVENT_ID}**/competitions/**{EVENT_ID}**/predictor](http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401437932/competitions/401437932/predictor)

- **Against-the-spread**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/**{YEAR}**/types/2/teams/**{TEAM_ID}**/ats](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2020/types/2/teams/26/ats)

- **Futures**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/**{YEAR}**/futures](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2020/futures)

- **Head-to-head (game)**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/**{EVENT_ID}**/competitions/**{EVENT_ID}**/odds/**{BET_PROVIDER_ID}**/head-to-heads](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401249063/competitions/401249063/odds/1002/head-to-heads)

- **Odds records**: (might encounter errors with older years)  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/**{YEAR}**/types/0/teams/**{TEAM_ID}**/odds-records](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2022/types/0/teams/4/odds-records)

- **Game odds**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/**{EVENT_ID}**/competitions/**{EVENT_ID}**/odds/**{BET_PROVIDER_ID}**/history/0/movement?limit=100](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401249063/competitions/401249063/odds/1002/history/0/movement?limit=100)

- **QBR Weekly/Game stats**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/**{YEAR}**/types/2/weeks/**{WEEK_NUM}**/qbr/10000](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2020/types/2/weeks/6/qbr/10000)

- **Past performances**: get spread, over/under odds, moneyline  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/teams/**{TEAM_ID}**/odds/**{BET_PROVIDER_ID}**/past-performances?limit=200](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/teams/10/odds/1002/past-performances?limit=200)

## Teams

- **Athletes**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/**{YEAR}**/teams/**{TEAM_ID}**/athletes?limit=200](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2023/teams/18/athletes?limit=200)

- **Team Events**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/**{YEAR}**/teams/**{TEAM_ID}**/events](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/teams/18/events)

- **List of NFL Teams (with id,logo,name)**:  
  [site.api.espn.com/apis/site/v2/sports/football/nfl/teams](https://site.api.espn.com/apis/site/v2/sports/football/nfl/teams)

- **Team**:  
  [site.api.espn.com/apis/site/v2/sports/football/nfl/teams/**{TEAM_ID}**](https://site.api.espn.com/apis/site/v2/sports/football/nfl/teams/1)

- **Teams (Season)**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/**{YEAR}**/teams](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/teams)

- **Team (season)**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/**{YEAR}**/teams/**{TEAM_ID}**](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/teams/24)

- **Current Leaders**:  
  [site.web.api.espn.com/apis/site/v3/sports/football/nfl/teamleaders](https://site.web.api.espn.com/apis/site/v3/sports/football/nfl/teamleaders)

- **Season Leaders**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/**{YEAR}**/types/**{SEASONTYPE}**/leaders](http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/leaders)

- **Record**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/**{YEAR}**/types/**{SEASONTYPE}**/teams/**{TEAM_ID}**/record](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2022/types/2/teams/6/record)

- **Depthcharts**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/**{YEAR}**/teams/**{TEAM_ID}**/depthcharts](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/teams/24/depthcharts)

- **Roster**:  
  [site.api.espn.com/apis/site/v2/sports/football/nfl/teams/**{TEAM_ID}**/roster](https://site.api.espn.com/apis/site/v2/sports/football/nfl/teams/4/roster)

- :star: **Detailed Roster**:  
  [site.api.espn.com/apis/site/v2/sports/football/nfl/teams/**{TEAM_ID}**?**enable=roster,projection,stats**](https://site.api.espn.com/apis/site/v2/sports/football/nfl/teams/4?enable=roster,projection,stats)

- **Schedule**:  
  [site.api.espn.com/apis/site/v2/sports/football/nfl/teams/**{TEAM_ID}**/schedule](https://site.api.espn.com/apis/site/v2/sports/football/nfl/teams/4/schedule)[`?season=`**{YEAR}**](https://site.api.espn.com/apis/site/v2/sports/football/nfl/teams/4/schedule?season=2019)

- **Injuries**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/teams/**{TEAM_ID}**/injuries](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/teams/8/injuries?limit=100)

- **Statistics**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/**{YEAR}**/types/**{SEASONTYPE}**/teams/**{TEAM_ID}**/statistics](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/teams/24/statistics)

- **Past performance**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/teams/**{TEAM_ID}**/odds/**{BET_PROVIDER_ID}**/past-performances?limit=140](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/teams/8/odds/1002/past-performances?limit=140)

- **Projection** (not valid for past seasons):  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/**2023**/teams/**{TEAM_ID}**/projection](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2023/teams/23/projection)

- **Season standing**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/**{YEAR}**/types/**{SEASONTYPE}**/groups/**{CONFERENCE_ID}**/standings](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/groups/8/standings)

  [AFC](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/groups/8/standings) (CONFERENCE_ID=8)  
  [NFC](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/groups/7/standings) (CONFERENCE_ID=7)

<br>[<sup>[TOC]</sup>](#table-of-contents)

## Games

- :star: **Summary**:   
  1 => [site.api.espn.com/apis/site/v2/sports/football/nfl/summary?event=**{EVENT_ID}**](https://site.api.espn.com/apis/site/v2/sports/football/nfl/summary?event=401326315)  
  2 => [site.web.api.espn.com/apis/site/v2/sports/football/nfl/summary?event=**{EVENT_ID}**](https://site.web.api.espn.com/apis/site/v2/sports/football/nfl/summary?event=401671808)

- **Events**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/events](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events)

- **Play by Plays**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/**{EVENT_ID}**/competitions/**{EVENT_ID}**/plays?limit=300](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401249063/competitions/401249063/plays?limit=300)

- **Drives**:   
  plays, drive start/end times, and total offensive plays   
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/**{EVENT_ID}**/competitions/**{EVENT_ID}**/drives](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401548411/competitions/401548411/drives)
  
- **Play probabilities**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/**{EVENT_ID}**/competitions/**{EVENT_ID}**/probabilities?limit=300](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401220181/competitions/401220181/probabilities?limit=300)

- **Linescores**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/**{EVENT_ID}**/competitions/**{EVENT_ID}**/competitors/**{TEAM_ID}**/linescores](http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401437932/competitions/401437932/competitors/6/linescores)

- **Records**:   
  Record Year To Date as of Event (wins, losses, streaks, etc)   
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/**{EVENT_ID}**/competitions/**{EVENT_ID}**/competitors/**{TEAM_ID}**/records](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401548411/competitions/401548411/competitors/10/records)

- **Scoring & All Splits**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/**{EVENT_ID}**/competitions/**{EVENT_ID}**/competitors/**{TEAM_ID}**/statistics](http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401437932/competitions/401437932/competitors/6/statistics)

- **Roster (get starters)**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/**{EVENT_ID}**/competitions/**{EVENT_ID}**/competitors/**{TEAM_ID}**/roster](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401220225/competitions/401220225/competitors/12/roster)

- **Weekly talent picks**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/**{YEAR}**/types/**{SEASONTYPE}**/weeks/**{WEEK_NUM}**/talentpicks?limit=100](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2020/types/2/weeks/6/talentpicks?limit=100)

- **Weekly event ids**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/**{YEAR}**/types/**{SEASONTYPE}**/weeks/**{WEEK_NUM}**/events](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/weeks/1/events)

- **QBR Weekly/Game stats**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/**{YEAR}**/types/**{SEASONTYPE}**/weeks/**{WEEK_NUM}**/qbr/10000?limit=100](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2020/types/2/weeks/6/qbr/10000?limit=100)

- **Game officials/judges**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/**{EVENT_ID}**/competitions/**{EVENT_ID}**/officials](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401437954/competitions/401437954/officials)

- **Expected margin of victory & predicted win percentage**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/**{EVENT_ID}**/competitions/**{EVENT_ID}**/powerindex/**{TEAM_ID}**](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401437954/competitions/401437954/powerindex/30)

## Athletes

- :star: **Splits**:  
  [site.web.api.espn.com/apis/common/v3/sports/football/nfl/athletes/**{ATHLETE_ID}**/splits](https://site.web.api.espn.com/apis/common/v3/sports/football/nfl/athletes/14876/splits)
  
- **Get all active player ids**:  
  [sports.core.api.espn.com/v3/sports/football/nfl/athletes?limit=20000&active=true](https://sports.core.api.espn.com/v3/sports/football/nfl/athletes?limit=20000&active=true)

- **Player stats for event**:

  - **Eventlog**:  
    [sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/**{YEAR}**/athletes/**{ATHLETE_ID}**/eventlog](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2022/athletes/14876/eventlog)

  - **Event stats**:  
    [sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/**{EVENT_ID}**/competitions/**{EVENT_ID}**/competitors/**{TEAM_ID}**/roster/**{ATHLETE_ID}**/statistics/0](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401437640/competitions/401437640/competitors/10/roster/14876/statistics/0)

- **Current leaders**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/leaders](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/leaders)

- **Leaders (year)**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/**{YEAR}**/types/**{SEASONTYPE}**/leaders](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/leaders)

- **Talent picks**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/talentpicks](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/talentpicks)

- :star: **Gamelog**:  
  [site.web.api.espn.com/apis/common/v3/sports/football/nfl/athletes/**{ATHLETE_ID}**/gamelog](https://site.web.api.espn.com/apis/common/v3/sports/football/nfl/athletes/14876/gamelog)

- **Coaches**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/**{YEAR}**/coaches?limit=50](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2022/coaches?limit=50)

- **Athletes v2**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/athletes](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/athletes)

- **Athletes v3**:  
  [sports.core.api.espn.com/v3/sports/football/nfl/athletes](https://sports.core.api.espn.com/v3/sports/football/nfl/athletes?limit=1000)

- **Player stats for each game**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/**{YEAR}**/athletes/**{ATHLETE_ID}**/eventlog](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2022/athletes/14876/eventlog)

- **statisticslog**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/athletes/**{ATHLETE_ID}**/statisticslog](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/athletes/2576336/statisticslog)

- :star: **Athlete Overview**:  
  [site.web.api.espn.com/apis/common/v3/sports/football/nfl/athletes/**{ATHLETE_ID}**/overview](https://site.web.api.espn.com/apis/common/v3/sports/football/nfl/athletes/14876/overview)

- **Free agents**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/**{YEAR}**/freeagents](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/freeagents)

- **Draft**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/**{YEAR}**/draft](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/draft)

- **Draft rounds**:  
  [site.web.api.espn.com/apis/v2/scoreboard/header?draft_year=**{YEAR}**&draft_round=1](https://site.web.api.espn.com/apis/v2/scoreboard/header?draft_year=2023&draft_round=1)

<br>[<sup>[TOC]</sup>](#table-of-contents)

## Calendar

- **Ondays**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/calendar/ondays](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/calendar/ondays)

- **Offdays**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/calendar/offdays](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/calendar/offdays)

- **Blacklist**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/calendar/blacklist](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/calendar/blacklist)

- **Whitelist dates**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/calendar/whitelist](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/calendar/whitelist)

- **Weeks**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/**{YEAR}**/types/**{SEASONTYPE}**/weeks](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/weeks)

- **Rankings, events, and talentpicks for week**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/**{YEAR}**/types/**{SEASONTYPE}**/weeks/**{WEEKNUM}**](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/weeks/1)
- **Season**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/**{YEAR}**](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021)

## Scoreboard

- **Day**:  
  [site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard?dates=**YYYYMMDD**](https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard?dates=20181213)

- **Week**:  
  [site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard?dates=**YYYY**&seasontype=**{SEASONTYPE}**&week=**{WEEKNUM}**](https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard?dates=2018&seasontype=2&week=1)

- **Year**:  
  [site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard?dates=**YYYY**&seasontype=2](https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard?dates=2018&seasontype=2)

- **Range** (cannot be more than 13 months):  
  [site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard?limit=1000&dates=**YYYYMMDD-YYYYMMDD**](https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard?limit=1000&dates=20200901-20210228)

  ***

  **Examples**:  
  site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard

  - [?dates=**2022**](https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard?limit=1000&dates=2022)
  - [?dates=**2022**&seasontype=**2**&week=**1**](https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard?dates=2022&seasontype=2&week=1)
  - [?dates=**20200901-20210228**](https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard?dates=20200901-20210228)
  - [?dates=**20200901**](https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard?dates=20200901)

## Leagues

- **Transactions**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/transactions](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/transactions)

- **Groups**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/**{YEAR}**/types/**{SEASONTYPE}**/groups](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/4/groups)

- **Franchises**:  
  [sports.core.api.espn.com/v2/sports/football/leagues/nfl/franchises](https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/franchises)

- **Header**:  
  [site.web.api.espn.com/apis/v2/scoreboard/header?sport=football&league=nfl](https://site.web.api.espn.com/apis/v2/scoreboard/header?sport=football&league=nfl)

## Search

- [site.web.api.espn.com/apis/common/v3/search?query=nfl&limit=5&mode=prefix](https://site.web.api.espn.com/apis/common/v3/search?query=nfl&limit=5&mode=prefix)

- [site.web.api.espn.com/apis/common/v3/search](https://site.web.api.espn.com/apis/common/v3/search)

<br>[<sup>[TOC]</sup>](#table-of-contents)

## Pick em challenges

> Parameters
>
> - **{USER_GAME_ID}**
> - **{GROUP_ID}**
> - **CHALLENGE {ID}** and **{NAME}**
>   - [231] nfl-win-totals-2023
>   - [232] nfl-eliminator-challenge-2023
>   - [230] nfl-pigskin-pickem-2023
> - **{VIEW_NAME}**
>   - :star: allon
>   - :star: chui_default
>   - chui_default_group
>   - chui_default_groupParticipationHistory
>   - chui_default_metadata
>   - chui_pagetype_group_picks
>   - pagetype_leaderboard

- **Scoring**:  
  [gambit-api.fantasy.espn.com/apis/v1/challenges/**${CHALLENGE_NAME}**?scoringPeriodId=**{WEEKNUM}**&view=**{VIEW_NAME}**](https://gambit-api.fantasy.espn.com/apis/v1/challenges/nfl-pigskin-pickem-2023?scoringPeriodId=3&platform=chui&view=allon)

- **Group**:  
  [gambit-api.fantasy.espn.com/apis/v1/challenges/**${CHALLENGE_NAME}**/groups/**{GROUP_ID}**?view=**{VIEW_NAME}**](https://gambit-api.fantasy.espn.com/apis/v1/challenges/nfl-win-totals-2023/groups/3ea0845b-59d5-499b-97a0-2eb9d02e1cc9?view=allon&platform=chui)

- :star: **User**  
  [gambit-api.fantasy.espn.com/apis/v1/challenges/**${CHALLENGE_NAME}**/entries/**{USER_GAME_ID}**?view=**{VIEW_NAME}**](https://gambit-api.fantasy.espn.com/apis/v1/challenges/nfl-pigskin-pickem-2023/entries/ac079fc0-4d4f-11ee-96d2-37e637e51967?platform=chui&view=chui_default)

- **Leaderboard**:  
  [gambit-api.fantasy.espn.com/apis/v1/challenges/**${CHALLENGE_NAME}**/leaderboard?view=**{VIEW_NAME}**](https://gambit-api.fantasy.espn.com/apis/v1/challenges/nfl-pigskin-pickem-2023/leaderboard?view=pagetype_leaderboard&platform=chui)

- **Propositions**:  
  [gambit-api.fantasy.espn.com/apis/v1/propositions?challengeId=**${CHALLENGE_ID}**&view=**{VIEW_NAME}**](https://gambit-api.fantasy.espn.com/apis/v1/propositions?challengeId=230&platform=chui&view=chui_default)

## Fantasy

> **v3 header:**  
> `X-Fantasy-Filter: {"players":{"limit":2000},"filterActive":{"value":true}}`

* **Current season**:  
  [fantasy.espn.com/apis/v3/games/ffl](https://fantasy.espn.com/apis/v3/games/ffl)

- **Players**:  
  [fantasy.espn.com/apis/v3/games/ffl/seasons/**{YEAR}**/players?view=players_wl](https://fantasy.espn.com/apis/v3/games/ffl/seasons/2023/players?view=players_wl)

  - [&view=mTeam&view=mRoster&view=mMatchup&view=mSettings](https://fantasy.espn.com/apis/v3/games/ffl/seasons/2019/players?view=mTeam&view=mRoster&view=mMatchup&view=mSettings)

- **Private league**:  
  [fantasy.espn.com/apis/v3/games/ffl/seasons/**{YEAR}**/segments/0/leagues/**{FANTASY_LEAGUE_ID}**](https://fantasy.espn.com/apis/v3/games/ffl/seasons/2019/segments/0/leagues/1241838?view=mDraftDetail&view=mLiveScoring&view=mMatchupScore&view=mPendingTransactions&view=mPositionalRatings&view=mSettings&view=mTeam&view=modular&view=mRoster)

  - season < 2018: [fantasy.espn.com/apis/v3/games/ffl/leagueHistory/**{FANTASY_LEAGUE_ID}**?seasonId=**{YEAR}**](https://fantasy.espn.com/apis/v3/games/ffl/leagueHistory/1241838?seasonId=2018&view=mDraftDetail&view=mLiveScoring&view=mMatchupScore&view=mPendingTransactions&view=mPositionalRatings&view=mSettings&view=mTeam&view=modular&view=mRoster)

  - season > 2018: [fantasy.espn.com/apis/v3/games/ffl/seasons/**{YEAR}**/segments/0/leagues/**{FANTASY_LEAGUE_ID}**](https://fantasy.espn.com/apis/v3/games/ffl/seasons/2019/segments/0/leagues/1241838?view=mDraftDetail&view=mLiveScoring&view=mMatchupScore&view=mPendingTransactions&view=mPositionalRatings&view=mSettings&view=mTeam&view=modular&view=mRoster)

### v2

- **Games**:  
  [site.web.api.espn.com/apis/fantasy/v2/games/ffl/games?dates=**YYYYMMDD**](https://site.web.api.espn.com/apis/fantasy/v2/games/ffl/games?dates=20210913&pbpOnly=true)
  - [dates=**YYYYMMDD-YYYYMMDD**](https://site.web.api.espn.com/apis/fantasy/v2/games/ffl/games?dates=20210901-20211108)

### Fantasy Filters

* **Get % owned for players**:  
  [fantasy.espn.com/apis/v3/games/ffl/seasons/**{YEAR}**/players?scoringPeriodId=0&view=players_wl](https://fantasy.espn.com/apis/v3/games/ffl/seasons/2023/players?scoringPeriodId=0&view=players_wl)

  ```sh
  curl -H 'X-Fantasy-Filter: {"filterActive":{"value":true}}' <URL>
  ```

  `X-Fantasy-Filter` is required in the request header to get all active players.  
  Omitting this returns only 50 items

  ---

* :star: **Get player info**:  
  [fantasy.espn.com/apis/v3/games/ffl/seasons/**{YEAR}**/segments/0/leaguedefaults/**{PPR_ID}**?view=kona_player_info](https://fantasy.espn.com/apis/v3/games/ffl/seasons/2023/segments/0/leaguedefaults/3?view=kona_player_info)

  ```sh
  curl -H 'X-Fantasy-Filter: {"players":{"limit":2000,"sortPercOwned":{"sortPriority":4,"sortAsc":false}}}' <URL>
  ```

  * `sortPercOwned` is required with `limit`
  * `PPR_ID` can be 1, 3, or 4. 

  ---

* **Get bye week for all teams**:  
  [fantasy.espn.com/apis/v3/games/ffl/seasons/**{YEAR}**?view=proTeamSchedules_wl](https://fantasy.espn.com/apis/v3/games/ffl/seasons/2023?view=proTeamSchedules_wl)

  ```sh
  jq '.settings.proTeams|map({name,byeWeek})'
  ```

### Fantasy Stats

- **Position**

  ```json
  { "1": "QB",
    "2": "RB",
    "3": "WR",
    "4": "TE",
    "5": "K",
   "16": "DST" }
  ```

- **Player stats**

  ```json
  {  "3": "passingYards",
     "4": "passingTouchdowns",
    "19": "passing2PtConversions",
    "20": "passingInterceptions",
    "24": "rushingYards",
    "25": "rushingTouchdowns",
    "26": "rushing2PtConversions",
    "42": "receivingYards",
    "43": "receivingTouchdowns",
    "44": "receiving2PtConversions",
    "53": "receivingReceptions",
    "72": "lostFumbles",
    "74": "madeFieldGoalsFrom50Plus",
    "77": "madeFieldGoalsFrom40To49",
    "80": "madeFieldGoalsFromUnder40",
    "85": "missedFieldGoals",
    "86": "madeExtraPoints",
    "88": "missedExtraPoints",
    "89": "defensive0PointsAllowed",
    "90": "defensive1To6PointsAllowed",
    "91": "defensive7To13PointsAllowed",
    "92": "defensive14To17PointsAllowed",
    "93": "defensiveBlockedKickForTouchdowns",
    "95": "defensiveInterceptions",
    "96": "defensiveFumbles",
    "97": "defensiveBlockedKicks",
    "98": "defensiveSafeties",
    "99": "defensiveSacks",
   "101": "kickoffReturnTouchdown",
   "102": "puntReturnTouchdown",
   "103": "fumbleReturnTouchdown",
   "104": "interceptionReturnTouchdown",
   "123": "defensive28To34PointsAllowed",
   "124": "defensive35To45PointsAllowed",
   "129": "defensive100To199YardsAllowed",
   "130": "defensive200To299YardsAllowed",
   "132": "defensive350To399YardsAllowed",
   "133": "defensive400To449YardsAllowed",
   "134": "defensive450To499YardsAllowed",
   "135": "defensive500To549YardsAllowed",
   "136": "defensiveOver550YardsAllowed" }
  ```

<br>[<sup>[TOC]</sup>](#table-of-contents)


## REST API Response Examples

**TABLE OF CONTENTS**

* [Table of Contents](#table-of-contents)
* [Reference List](#reference-list)
* [News](#news)
* [Detailed](#detailed)
* [Odds](#odds)
* [Teams](#teams)
* [Games](#games)
* [Athletes](#athletes)
* [Calendar](#calendar)
* [Scoreboard](#scoreboard)
* [Leagues](#leagues)
* [Search](#search)
* [Pick em challenges](#pick-em-challenges)
* [Fantasy](#fantasy)
  * [v2](#v2)
  * [Fantasy Filters](#fantasy-filters)
  * [Fantasy Stats](#fantasy-stats)
* [REST API Response Examples](#rest-api-response-examples)
  * [ATHLETE PROFILE API](#athlete-profile-api)
  * [ATHLETE BIO API](#athlete-bio-api)
  * [ATHLETE EVENTLOG API](#athlete-eventlog-api)
  * [ATHLETE GAMELOG API](#athlete-gamelog-api)
  * [ATHLETE NOTES API](#athlete-notes-api)
  * [ATHLETE PROJECTIONS API](#athlete-projections-api)
  * [ATHLETE SPLITS API](#athlete-splits-api)
  * [ATHLETE STATISTICS API](#athlete-statistics-api)
  * [ATHLETE STATISTICSLOG API](#athlete-statisticslog-api)
  * [ATHLETE STATS API](#athlete-stats-api)
  * [CALENDAR API](#calendar-api)
  * [CALENDAR BLACKLIST API](#calendar-blacklist-api)
  * [CALENDAR WHITELIST API](#calendar-whitelist-api)
  * [GAME PREDICTION API](#game-prediction-api)
  * [COMPETITION DRIVES API](#competition-drives-api)
  * [BETTING ODDS API](#betting-odds-api)
  * [COMPETITION PLAYS API](#competition-plays-api)
  * [GETS ALL PLAYS FOR A GAME: API](#gets-all-plays-for-a-game-api)
  * [COMPETITION PROBABILITIES API](#competition-probabilities-api)
  * [COMPETITOR ROSTER API](#competitor-roster-api)
  * [DRAFT ATHLETES API](#draft-athletes-api)
  * [DRAFT ROUNDS API](#draft-rounds-api)
  * [DRAFT STATUS API](#draft-status-api)
  * [EVENTS API](#events-api)
  * [EVENT COMPETITIONS API](#event-competitions-api)
  * [FRANCHISES API](#franchises-api)
  * [GROUP STANDINGS API](#group-standings-api)
  * [GROUP TEAMS API](#group-teams-api)
  * [LEADERS API](#leaders-api)
  * [NEWS API](#news-api)
  * [ODD PREDICTORS API](#odd-predictors-api)
  * [POSITIONS API](#positions-api)
  * [PROVIDERS API](#providers-api)
  * [SCOREBOARD API](#scoreboard-api)
  * [SEASONS API](#seasons-api)
  * [SEASON ATHLETES API](#season-athletes-api)
  * [SEASON COACHES API](#season-coaches-api)
  * [SEASON DRAFT API](#season-draft-api)
  * [SEASON FUTURES API](#season-futures-api)
  * [SEASON TEAMS API](#season-teams-api)
  * [SEASON TYPES API](#season-types-api)
  * [TALENTPICKS API](#talentpicks-api)
  * [TEAM API](#team-api)
  * [TEAM ATHLETES API](#team-athletes-api)
  * [TEAM ATS API](#team-ats-api)
  * [TEAM ATTENDANCE API](#team-attendance-api)
  * [TEAM COACHES API](#team-coaches-api)
  * [TEAM DEPTHCHARTS API](#team-depthcharts-api)
  * [TEAM EVENTS API](#team-events-api)
  * [TEAM INJURIES API](#team-injuries-api)
  * [TEAM LEADERS API](#team-leaders-api)
  * [TEAM ODDS-RECORDS API](#team-odds-records-api)
  * [TEAM PROJECTION API](#team-projection-api)
  * [TEAM RECORD API](#team-record-api)
  * [TEAM ROSTER API](#team-roster-api)
  * [TEAM SCHEDULE API](#team-schedule-api)
  * [TEAM STATISTICS API](#team-statistics-api)
  * [SEASONTYPE GROUPS API](#seasontype-groups-api)
  * [SEASONTYPE LEADERS API](#seasontype-leaders-api)
  * [SEASONTYPE WEEKS API](#seasontype-weeks-api)
  * [VENUES API](#venues-api)
  * [WEEKLY EVENTS API](#weekly-events-api)
  * [WEEKLY QBR API](#weekly-qbr-api)
  * [WEEKLY TALENTPICKS API](#weekly-talentpicks-api)

<br>
<details><summary>Expand for view</summary>
<br>

<div id="top"></div>

### ATHLETE PROFILE API

**URL**: https://site.web.api.espn.com/apis/common/v3/sports/football/nfl/athletes/14876

```json
{
  "athlete": {
    "id": "14876",
    "uid": "s:20~l:28~a:14876",
    "guid": "2d6af5dcb3d3e2d4cf7227d4a8eb93cd",
    "type": "football",
    "firstName": "Ryan",
    "lastName": "Tannehill",
    "displayName": "Ryan Tannehill",
    "fullName": "Ryan Tannehill",
    "debutYear": 2012,
    "jersey": "17",
    "links": [
      {
        "language": "en",
```

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/athletes?limit=1000

```json
{
  "count": 4559,
  "pageIndex": 1,
  "pageSize": 1000,
  "pageCount": 5,
  "items": [
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/athletes/2576336"
    },
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/athletes/3049325"
    },
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/athletes/3915373"
    },
```

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/athletes/14876

```json
{
  "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/athletes/12483",
  "id": "12483",
  "uid": "s:20~l:28~a:12483",
  "guid": "20c41c33a33f6dc27e1f0771e39ce49a",
  "type": "football",
  "alternateIds": {
    "sdr": "2219510"
  },
  "firstName": "Matthew",
  "lastName": "Stafford",
  "fullName": "Matthew Stafford",
  "displayName": "Matthew Stafford",
  "shortName": "M. Stafford",
  "weight": 220,
```

[[TOP]](#top)

### ATHLETE BIO API

**URL**: https://site.web.api.espn.com/apis/common/v3/sports/football/nfl/athletes/14876/bio

```json
{
  "teamHistory": [
    {
      "id": "10",
      "uid": "s:20~l:28~t:10",
      "slug": "tennessee-titans",
      "displayName": "Tennessee Titans",
      "logo": "https://a.espncdn.com/i/teamlogos/nfl/500/ten.png",
      "seasons": "2019-CURRENT",
      "links": [
        {
          "language": "en",
          "rel": [
            "clubhouse",
            "desktop",
```

[[TOP]](#top)

### ATHLETE EVENTLOG API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2022/athletes/14876/eventlog

```json
{
  "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2022/athletes/14876/eventlog",
  "teams": {
    "10": {
      "team": {
        "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2022/teams/10"
      },
      "id": "10"
    }
  },
  "events": {
    "count": 17,
    "pageIndex": 1,
    "pageSize": 25,
    "pageCount": 1,
    "items": [
      {
        "event": {
          "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401437640"
        },
        "competition": {
          "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401437640/competitions/401437640"
        },
        "statistics": {
          "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401437640/competitions/401437640/competitors/10/roster/14876/statistics/0"
        },
        "teamId": "10",
        "played": true
      },
```

[[TOP]](#top)

### ATHLETE GAMELOG API

**URL**: https://site.web.api.espn.com/apis/common/v3/sports/football/nfl/athletes/14876/gamelog

```json
{
  "categories": [
    {
      "name": "passing",
      "displayName": "Passing",
      "count": 11
    },
    {
      "name": "rushing",
      "displayName": "Rushing",
      "count": 5
    }
  ],
  "filters": [
    {
```

[[TOP]](#top)

### ATHLETE NOTES API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/athletes/14876/notes

```json
{
  "count": 1,
  "pageIndex": 1,
  "pageSize": 25,
  "pageCount": 1,
  "items": [
    {
      "id": "498444",
      "type": "news",
      "date": "2021-12-17T20:14Z",
      "headline": "Stafford and the Rams aren't in line to play the Seahawks on Sunday, with the NFL expected to reschedule the game for Tuesday at 7 p.m. ET, pending official confirmation, Adam Schefter of ESPN reports.",
      "text": "Due to ongoing COVID-19-related issues within the Rams organization, the NFL is hopeful that by delaying the game two days, Los Angeles will be able to restore enough players from the reserve/COVID-19 list to alleviate depth concerns on the roster. After Tuesday's game, the Rams will face a quick turnaround for Week 16 with a Sunday game in Minnesota on Dec. 26.",
      "source": "RotoWire"
    }
  ]
}
```

[[TOP]](#top)

### ATHLETE PROJECTIONS API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/athletes/14876/projections

```json
{
  "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/athletes/14876/statistics/0",
  "season": {
    "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021"
  },
  "athlete": {
    "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/athletes/14876"
  },
  "splits": {
    "id": "0",
    "name": "All Splits",
    "abbreviation": "Any",
    "type": "total",
    "categories": [
      {
```

[[TOP]](#top)

### ATHLETE SPLITS API

**URL**: https://site.web.api.espn.com/apis/common/v3/sports/football/nfl/athletes/14876/splits

```json
{
  "filters": [
    {
      "displayName": "League",
      "name": "league",
      "value": "nfl",
      "options": [
        {
          "value": "college-football",
          "displayValue": "NCAAF"
        },
        {
          "value": "nfl",
          "displayValue": "NFL"
        }
```

[[TOP]](#top)

### ATHLETE STATISTICS API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/athletes/14876/statistics/0

```json
{
  "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/athletes/12483/statistics/0",
  "athlete": {
    "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/athletes/12483"
  },
  "splits": {
    "id": "0",
    "name": "All Splits",
    "abbreviation": "Any",
    "categories": [
      {
        "name": "general",
        "displayName": "General",
        "shortDisplayName": "General",
        "abbreviation": "gen",
```

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/athletes/14876/statistics

```json
{
  "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/athletes/14876/statistics/0",
  "season": {
    "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021"
  },
  "athlete": {
    "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/athletes/14876"
  },
  "splits": {
    "id": "0",
    "name": "All Splits",
    "abbreviation": "Any",
    "type": "total",
    "categories": [
      {
```

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/athletes/14876/statistics/0

```json
{
  "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/athletes/12483/statistics/0",
  "season": {
    "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021"
  },
  "athlete": {
    "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/athletes/12483"
  },
  "splits": {
    "id": "0",
    "name": "All Splits",
    "abbreviation": "Any",
    "type": "total",
    "categories": [
      {
```

[[TOP]](#top)

### ATHLETE STATISTICSLOG API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/athletes/14876/statisticslog

```json
{
  "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/athletes/14876/statisticslog",
  "entries": [
    {
      "season": {
        "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021"
      },
      "statistics": [
        {
          "type": "total",
          "statistics": {
            "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/athletes/14876/statistics/0"
          }
        },
        {
```

[[TOP]](#top)

### ATHLETE STATS API

**URL**: https://site.web.api.espn.com/apis/common/v3/sports/football/nfl/athletes/14876/stats

```json
{
  "filters": [
    {
      "displayName": "League",
      "name": "league",
      "value": "nfl",
      "options": [
        {
          "value": "college-football",
          "displayValue": "NCAAF"
        },
        {
          "value": "nfl",
          "displayValue": "NFL"
        }
```

[[TOP]](#top)

### CALENDAR API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/calendar

```json
{
  "count": 4,
  "pageIndex": 1,
  "pageSize": 25,
  "pageCount": 1,
  "items": [
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/calendar/ondays"
    },
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/calendar/offdays"
    },
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/calendar/whitelist"
    },
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/calendar/blacklist"
    }
  ]
}
```

[[TOP]](#top)

### CALENDAR BLACKLIST API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/calendar/blacklist

```json
{
  "type": "list",
  "startDate": "2021-07-17T07:00Z",
  "endDate": "2022-02-16T07:59Z",
  "eventDate": {
    "type": "blacklist",
    "dates": [
      "2021-07-17T07:00Z",
      "2021-07-18T07:00Z",
      "2021-07-19T07:00Z",
      "2021-07-20T07:00Z",
      "2021-07-21T07:00Z",
      "2021-07-22T07:00Z",
      "2021-07-23T07:00Z",
```

[[TOP]](#top)

### CALENDAR WHITELIST API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/calendar/whitelist

```json
{
  "type": "list",
  "startDate": "2021-07-17T07:00Z",
  "endDate": "2022-02-16T07:59Z",
  "eventDate": {
    "type": "whitelist",
    "dates": [
      "2021-08-05T07:00Z",
      "2021-08-12T07:00Z",
      "2021-08-13T07:00Z",
      "2021-08-14T07:00Z",
      "2021-08-15T07:00Z",
      "2021-08-19T07:00Z",
      "2021-08-20T07:00Z",
```

[[TOP]](#top)

### GAME PREDICTION API

Example: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401437954/competitions/401437954/powerindex/30

```json
{
  "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401437954/competitions/401437954/powerindex/30?lang=en&region=us",
  "team": {
    "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2022/teams/30?lang=en&region=us"
  },
  "season": 2022,
  "stats": [
    {
      "name": "teampredptdiff",
      "displayName": "PRED PT DIFF",
      "description": "Expected margin of victory for the FPI favorite.",
      "abbreviation": "PRED PT DIFF",
      "value": 12.175,
      "displayValue": "12.2"
    },
    {
      "name": "gameprojection",
      "displayName": "WIN PROB",
      "description": "Team's predicted win percentage in this game at time of given BPI run",
      "abbreviation": "GAME PROJ",
      "value": 84.81,
      "displayValue": "84.8%"
    },
    {
      "name": "matchupquality",
      "displayName": "MATCHUP QUALITY",
      "description": "A measure of projected competitiveness and excitement in the game, using a 0 to 100 scale, with 100 as the most exciting",
      "abbreviation": "MATCHUP QUALITY",
      "value": 35.261,
      "displayValue": "35.3"
    },
    {
      "name": "teamadjgamescore",
      "displayName": "GAME SCORE",
      "description": "A measure of how well a team performed compared to their expected performance and the expected performance of a typical top 25 team.",
      "abbreviation": "TEAM ADJ GAMESCORE",
      "displayValue": ""
    }
  ]
}
```

[[TOP]](#top)

### COMPETITION DRIVES API

http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401249063/competitions/401249063/drives/4012490631

```json
{
  "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401249063/competitions/401249063/drives/4012490631",
  "id": "4012490631",
  "description": "16 plays, 75 yards, 9:18",
  "sequenceNumber": "1",
  "team": {
    "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/teams/23"
  },
  "endTeam": {
    "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/teams/23"
  },
  "start": {
    "period": {
      "type": "quarter",
      "number": 1
```

[[TOP]](#top)

### BETTING ODDS API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401220181/competitions/401220181/odds

```json
},{
  "provider": {
    "id": "1001",
    "name": "accuscore",
    "priority": 0
  },
  "details": "BAL -7.5",
  "overUnder": 49,
  "spread": 7.5,
  "overOdds": -111,
  "underOdds": -111,
  "awayTeamOdds": {
    "favorite": true,
    "underdog": false,
    "moneyLine": -370,
    "spreadOdds": -111,
    "team": {}
  },
  "homeTeamOdds": {
    "favorite": false,
    "underdog": true,
    "moneyLine": 280,
    "spreadOdds": -111,
    "team": {}
  },
  "moneylineWinner": false,
  "spreadWinner": false
},
```

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401326315/competitions/401326315/odds/1003

```json
{
  "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401326315/competitions/401326315/odds/1003",
  "provider": {
    "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/providers/1003",
    "id": "1003",
    "name": "numberfire",
    "priority": 0
  },
  "details": "ATL -3.5",
  "overUnder": 48.5,
  "spread": -3.5,
  "overOdds": 45.31,
  "underOdds": 54.69,
  "awayTeamOdds": {
    "averageScore": 20.62,
```

[[TOP]](#top)

### COMPETITION PLAYS API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401249063/competitions/401249063/plays/4012490631

```json
{
  "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401249063/competitions/401249063/plays/4012490631",
  "id": "4012490631",
  "sequenceNumber": "100",
  "type": {
    "id": "70",
    "text": "Coin Toss"
  },
  "text": "GAME",
  "shortText": "PIT Win Toss, Elect to Receive",
  "alternativeText": "GAME",
  "shortAlternativeText": "PIT Win Toss, Elect to Receive",
  "awayScore": 0,
  "homeScore": 0,
  "period": {
```

[[TOP]](#top)

### GETS ALL PLAYS FOR A GAME: API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401220181/competitions/401220181/plays?limit=400

```json
{
  "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401220181/competitions/401220181/plays?source=2",
  "count": 167,
  "pageIndex": 1,
  "pageSize": 100,
  "pageCount": 2,
  "items": [
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401220181/competitions/401220181/plays/4012201811",
      "id": "4012201811",
      "sequenceNumber": "100",
      "type": {
        "id": "70",
        "text": "Coin Toss"
      },
```

[[TOP]](#top)

### COMPETITION PROBABILITIES API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401326315/competitions/401326315/probabilities/4012490631

```json
{
  "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401326315/competitions/401326315/probabilities/4012490631",
  "competition": {
    "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401326315/competitions/401326315"
  },
  "play": {
    "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401326315/competitions/401326315/plays/4012490631"
  },
  "homeTeam": {
    "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/teams/1"
  },
  "awayTeam": {
    "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/teams/21"
  },
  "tiePercentage": 0,
```

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401220181/competitions/401220181/probabilities?limit=200

```json
{
  "count": 166,
  "pageIndex": 1,
  "pageSize": 200,
  "pageCount": 1,
  "items": [
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401220181/competitions/401220181/probabilities/4012201811",
      "competition": {
        "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401220181/competitions/401220181"
      },
      "play": {
        "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401220181/competitions/401220181/plays/4012201811"
      },
      "homeTeam": {
        "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2020/teams/34"
      },
      "awayTeam": {
        "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2020/teams/33"
      },
      "tiePercentage": 0,
      "homeWinPercentage": 0.312,
      "awayWinPercentage": 0.688,
      "lastModified": "2020-09-21T00:14Z",
      "sequenceNumber": "100",
      "source": {
        "id": "2",
        "description": "feed",
        "state": "full"
      },
      "secondsLeft": 0
    },
```

[[TOP]](#top)

### COMPETITOR ROSTER API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401220181/competitions/401220181/competitors/34/roster

```json
{
  "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401220181/competitions/401220181/competitors/34/roster",
  "entries": [
    {
      "playerId": 13979,
      "period": 0,
      "active": false,
      "starter": true,
      "forPlayerId": 0,
      "jersey": "99",
      "valid": true,
      "athlete": {
        "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2020/athletes/13979"
      },
      "position": {
```

[[TOP]](#top)

### DRAFT ATHLETES API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/draft/athletes?limit=500

```json
{
  "count": 366,
  "pageIndex": 1,
  "pageSize": 500,
  "pageCount": 1,
  "items": [
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/draft/athletes/104734"
    },
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/draft/athletes/104760"
    },
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/draft/athletes/104737"
    },
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/draft/athletes/104933"
```

[[TOP]](#top)

### DRAFT ROUNDS API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/draft/rounds

```json
{
  "count": 7,
  "pageIndex": 1,
  "pageSize": 25,
  "pageCount": 1,
  "items": [
    {
      "number": 1,
      "displayName": "1st Round",
      "shortDisplayName": "1st",
      "picks": [
        {
          "status": {
            "id": 3,
            "name": "SELECTION_MADE",
```

[[TOP]](#top)

### DRAFT STATUS API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/draft/status

```json
{
  "round": 7,
  "type": {
    "id": 3,
    "name": "COMPLETED",
    "state": "post",
    "description": "Completed"
  }
}
```

[[TOP]](#top)

### EVENTS API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events

```json
{
  "$meta": {
    "parameters": {
      "week": [
        "15"
      ],
      "season": [
        "2021"
      ],
      "seasontypes": [
        "2"
      ]
    }
  },
  "count": 16,
```

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401326315

```json
{
  "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401326315",
  "id": "401326315",
  "uid": "s:20~l:28~e:401326315",
  "date": "2021-09-12T17:00Z",
  "name": "Philadelphia Eagles at Atlanta Falcons",
  "shortName": "PHI @ ATL",
  "season": {
    "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021"
  },
  "seasonType": {
    "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2"
  },
  "week": {
    "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/weeks/1"
```

[[TOP]](#top)

### EVENT COMPETITIONS API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401326315/competitions/401326315

```json
{
  "id": "401326315",
  "guid": "b64e5dc5-c943-33e6-a6c9-44008b28b11a",
  "uid": "s:20~l:28~e:401326315~c:401326315",
  "date": "2021-09-12T17:00Z",
  "attendance": 68633,
  "type": {
    "id": "1",
    "text": "Standard",
    "abbreviation": "STD",
    "slug": "standard",
    "type": "standard"
  },
  "necessary": false,
```

[[TOP]](#top)

### FRANCHISES API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/franchises

```json
{
  "count": 32,
  "pageIndex": 1,
  "pageSize": 25,
  "pageCount": 2,
  "items": [
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/franchises/1"
    },
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/franchises/2"
    },
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/franchises/3"
    },
```

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/franchises/1

```json
{
  "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/franchises/1",
  "id": "1",
  "uid": "s:20~l:28~f:1",
  "slug": "atlanta-falcons",
  "location": "Atlanta",
  "name": "Falcons",
  "nickname": "Atlanta",
  "abbreviation": "ATL",
  "displayName": "Atlanta Falcons",
  "shortDisplayName": "Falcons",
  "color": "000000",
  "isActive": true,
  "logos": [
    {
```

[[TOP]](#top)

### GROUP STANDINGS API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/groups/1/standings

```json
{
  "count": 4,
  "pageIndex": 1,
  "pageSize": 25,
  "pageCount": 1,
  "items": [
    {
      "id": "0",
      "name": "overall",
      "displayName": "Overall Standings",
      "links": [
        {
          "language": "en-US",
          "rel": [
```

[[TOP]](#top)

### GROUP TEAMS API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/groups/1/teams

```json
{
  "count": 4,
  "pageIndex": 1,
  "pageSize": 25,
  "pageCount": 1,
  "items": [
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/teams/6"
    },
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/teams/19"
    },
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/teams/21"
    },
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/teams/28"
    }
  ]
}
```

[[TOP]](#top)

### LEADERS API

**URL**: https://site.api.espn.com/apis/site/v3/sports/football/nfl/leaders?season=2021

```json
  "leaders": {
    "id": "0",
    "name": "TOTAL",
    "abbreviation": "Any",
    "categories": [
      {
        "name": "passingYards",
        "displayName": "Passing Yards",
        "abbreviation": "YDS",
        "leaders": [
          {
            "displayValue": "404",
            "value": 404,
            "rel": [
              "athlete"
            ],
            "athlete": {
              "id": "3139477",
              "uid": "s:20~l:28~a:3139477",
              "guid": "37d87523280a9d4a0adb22cfc6d3619c",
              "firstName": "Patrick",
              "lastName": "Mahomes",
              "displayName": "Patrick Mahomes",
              "fullName": "Patrick Mahomes",
```

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/leaders

```json
{
  "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/leaders/0",
  "id": "0",
  "name": "total",
  "abbreviation": "TOTAL",
  "categories": [
    {
      "name": "totalPoints",
      "displayName": "Total Points",
      "shortDisplayName": "TP",
      "abbreviation": "TP",
      "leaders": [
        {
          "displayValue": "2673",
          "value": 2673,
```

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/leaders/0

```json
{
  "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/leaders/0",
  "id": "0",
  "name": "total",
  "abbreviation": "TOTAL",
  "categories": [
    {
      "name": "totalPoints",
      "displayName": "Total Points",
      "shortDisplayName": "TP",
      "abbreviation": "TP",
      "leaders": [
        {
          "displayValue": "2673",
          "value": 2673,
```

[[TOP]](#top)

### NEWS API

**URL**: https://site.api.espn.com/apis/site/v2/sports/football/nfl/news

```json
{
  "header": "NFL News",
  "link": {
    "language": "en",
    "rel": [
      "index",
      "desktop",
      "league"
    ],
    "href": "https://www.espn.com/nfl/",
    "text": "All NFL News",
    "shortText": "All News",
    "isExternal": false,
    "isPremium": false
  },
```

[[TOP]](#top)

### ODD PREDICTORS API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401326315/competitions/401326315/odds/1003/predictors

```json
{
  "count": 5,
  "pageIndex": 1,
  "pageSize": 25,
  "pageCount": 1,
  "items": [
    {
      "rank": 1,
      "total": "OVER",
      "value": 90.363,
      "displayValue": "90.4",
      "predictorCompetition": {
        "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401326315/competitions/401326315"
      },
      "projectedWinner": {
        "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/teams/8"
      },
      "cover": {
        "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/teams/8"
      },
      "projectedCover": {
        "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/teams/1"
      }
    },
```

[[TOP]](#top)

### POSITIONS API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/positions/8

```json
{
  "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/positions/8",
  "id": "8",
  "name": "Quarterback",
  "displayName": "Quarterback",
  "abbreviation": "QB",
  "leaf": true,
  "parent": {
    "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/positions/70"
  }
}
```

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/positions?limit=100

```json
{
  "count": 73,
  "pageIndex": 1,
  "pageSize": 100,
  "pageCount": 1,
  "items": [
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/positions/0"
    },
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/positions/1"
    },
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/positions/2"
    },
```

[[TOP]](#top)

### PROVIDERS API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/providers/1003

```json
{
  "id": "1003",
  "name": "numberfire",
  "priority": 0
}
```

[[TOP]](#top)

### SCOREBOARD API

**URL**: https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard

```json
{
  "leagues": [
    {
      "id": "28",
      "uid": "s:20~l:28",
      "name": "National Football League",
      "abbreviation": "NFL",
      "slug": "nfl",
      "season": {
        "year": 2021,
        "startDate": "2021-07-17T07:00Z",
        "endDate": "2022-02-16T07:59Z",
        "type": {
          "id": "2",
          "type": 2,
```

[[TOP]](#top)

### SEASONS API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons

```json
{
  "count": 100,
  "pageIndex": 1,
  "pageSize": 25,
  "pageCount": 4,
  "items": [
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021"
    },
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2020"
    },
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2019"
    },
```

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021

```json
{
  "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021",
  "year": 2021,
  "startDate": "2021-07-17T07:00Z",
  "endDate": "2022-02-16T07:59Z",
  "displayName": "2021",
  "type": {
    "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2",
    "id": "2",
    "type": 2,
    "name": "Regular Season",
    "abbreviation": "reg",
    "year": 2021,
    "startDate": "2021-09-09T07:00Z",
    "endDate": "2022-01-13T07:59Z",
```

[[TOP]](#top)

### SEASON ATHLETES API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/athletes

```json
{
  "count": 16438,
  "pageIndex": 1,
  "pageSize": 25,
  "pageCount": 658,
  "items": [
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/athletes/4246273"
    },
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/athletes/4246281"
    },
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/athletes/4246289"
    },
```

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/athletes/14876

```json
{
  "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/athletes/14876",
  "id": "14876",
  "uid": "s:20~l:28~a:14876",
  "guid": "2d6af5dcb3d3e2d4cf7227d4a8eb93cd",
  "type": "football",
  "alternateIds": {
    "sdr": "2268110"
  },
  "firstName": "Ryan",
  "lastName": "Tannehill",
  "fullName": "Ryan Tannehill",
  "displayName": "Ryan Tannehill",
  "shortName": "R. Tannehill",
  "weight": 217,
```

[[TOP]](#top)

### SEASON COACHES API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/coaches?limit=50

```json
{
  "count": 32,
  "pageIndex": 1,
  "pageSize": 25,
  "pageCount": 2,
  "items": [
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/coaches/17739"
    },
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/coaches/2552857"
    },
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/coaches/13162"
    },
```

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/coaches/4408695

```json
{
  "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/coaches/4408695",
  "id": "4408695",
  "uid": "s:20~l:28~co:4408695",
  "firstName": "Kevin",
  "lastName": "Stefanski",
  "team": {
    "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/teams/5"
  },
  "experience": 1,
  "careerRecords": [
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/coaches/4408695/record/0"
    },
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/coaches/4408695/record/2"
    },
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/coaches/4408695/record/3"
    }
  ],
  "coachSeasons": [
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2020/coaches/4408695"
    },
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/coaches/4408695"
    }
  ]
}
```

[[TOP]](#top)

### SEASON DRAFT API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/draft

```json
{
  "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/draft",
  "uid": "s:20~l:28~e:DRAFT~y:2021",
  "year": 2021,
  "numberOfRounds": 7,
  "displayName": "2021 National Football League Draft",
  "shortDisplayName": "2021 NFL Draft",
  "status": {
    "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/draft/status"
  },
  "athletes": {
    "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/draft/athletes"
  },
  "rounds": {
    "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/draft/rounds"
```

[[TOP]](#top)

### SEASON FUTURES API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/futures

```json
{
  "count": 7,
  "pageIndex": 1,
  "pageSize": 25,
  "pageCount": 1,
  "items": [
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/futures/1561",
      "id": 1561,
      "name": "Pro Football Champion",
      "futures": [
        {
          "provider": {
            "id": "40",
            "name": "DraftKings",
```

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/futures/1561

```json
{
  "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/futures/1561",
  "id": 1561,
  "name": "Pro Football Champion",
  "futures": [
    {
      "provider": {
        "id": "40",
        "name": "DraftKings",
        "active": 1,
        "priority": 0
      },
      "books": [
        {
          "team": {
```

[[TOP]](#top)

### SEASON TEAMS API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/teams

```json
{
  "count": 32,
  "pageIndex": 1,
  "pageSize": 25,
  "pageCount": 2,
  "items": [
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/teams/1"
    },
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/teams/2"
    },
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/teams/3"
    },
```

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/teams/12

```json
{
  "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/teams/1",
  "id": "1",
  "guid": "49fd392a86fe4df31b779bbfa18b2ad5",
  "uid": "s:20~l:28~t:1",
  "alternateIds": {
    "sdr": "8802"
  },
  "slug": "atlanta-falcons",
  "location": "Atlanta",
  "name": "Falcons",
  "nickname": "Atlanta",
  "abbreviation": "ATL",
  "displayName": "Atlanta Falcons",
  "shortDisplayName": "Falcons",
```

[[TOP]](#top)

### SEASON TYPES API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types

```json
{
  "count": 4,
  "pageIndex": 1,
  "pageSize": 25,
  "pageCount": 1,
  "items": [
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/1"
    },
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2"
    },
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/3"
    },
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/4"
    }
  ]
}
```

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2

```json
{
  "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2",
  "id": "2",
  "type": 2,
  "name": "Regular Season",
  "abbreviation": "reg",
  "year": 2021,
  "startDate": "2021-09-09T07:00Z",
  "endDate": "2022-01-13T07:59Z",
  "hasGroups": false,
  "hasStandings": true,
  "hasLegs": false,
  "groups": {
    "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/groups"
  },
```

[[TOP]](#top)

### TALENTPICKS API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/talentpicks

```json
{
  "count": 176,
  "pageIndex": 1,
  "pageSize": 25,
  "pageCount": 8,
  "items": [
    {
      "pick": {
        "person": {
          "id": "1768",
          "firstName": "Damien",
          "lastName": "Woody",
          "displayName": "Damien Woody",
          "headshot": {
            "href": "https://a.espncdn.com/i/columnists/full/woody_damien.png",
```

[[TOP]](#top)

### TEAM API

**URL**: https://site.api.espn.com/apis/site/v2/sports/football/nfl/teams

```json
{
  "sports": [
    {
      "id": "20",
      "uid": "s:20",
      "name": "Football",
      "slug": "football",
      "leagues": [
        {
          "id": "28",
          "uid": "s:20~l:28",
          "name": "National Football League",
          "abbreviation": "NFL",
          "shortName": "NFL",
          "slug": "nfl",
```

**URL**: https://site.api.espn.com/apis/site/v2/sports/football/nfl/teams/12

```json
{
  "team": {
    "id": "1",
    "uid": "s:20~l:28~t:1",
    "slug": "atlanta-falcons",
    "location": "Atlanta",
    "name": "Falcons",
    "nickname": "Atlanta",
    "abbreviation": "ATL",
    "displayName": "Atlanta Falcons",
    "shortDisplayName": "Falcons",
    "color": "000000",
    "alternateColor": "000000",
    "isActive": true,
    "logos": [
```

[[TOP]](#top)

### TEAM ATHLETES API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/teams/12/athletes

```json
{
  "count": 76,
  "pageIndex": 1,
  "pageSize": 25,
  "pageCount": 4,
  "items": [
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/athletes/16963"
    },
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/athletes/3123963"
    },
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/athletes/16299"
    },
```

[[TOP]](#top)

### TEAM ATS API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/teams/12/ats

```json
{
  "count": 9,
  "pageIndex": 1,
  "pageSize": 25,
  "pageCount": 1,
  "items": [
    {
      "wins": 6,
      "losses": 8,
      "pushes": 0,
      "type": {
        "id": "0",
        "name": "atsOverall",
        "description": "Overall team season record against the spread"
      }
```

[[TOP]](#top)

### TEAM ATTENDANCE API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/teams/12/attendance

```json
{
  "id": "0",
  "name": "Attendance",
  "abbreviation": "ATTND",
  "categories": [
    {
      "name": "home",
      "displayName": "Home",
      "shortDisplayName": "Home",
      "abbreviation": "home",
      "stats": [
        {
          "name": "games",
          "displayName": "Home Games",
```

[[TOP]](#top)

### TEAM COACHES API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/teams/12/coaches

```json
{
  "count": 1,
  "pageIndex": 1,
  "pageSize": 25,
  "pageCount": 1,
  "items": [{}]
}
```

[[TOP]](#top)

### TEAM DEPTHCHARTS API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/teams/12/depthcharts

```json
{
  "count": 3,
  "pageIndex": 1,
  "pageSize": 25,
  "pageCount": 1,
  "items": [
    {
      "id": "15",
      "name": "Base 3-4 D",
      "positions": {
        "lde": {
          "position": {
            "id": "11",
            "name": "Left Defensive End",
```

[[TOP]](#top)

### TEAM EVENTS API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/teams/12/events

```json
{
  "count": 20,
  "pageIndex": 1,
  "pageSize": 25,
  "pageCount": 1,
  "items": [
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401326621"
    },
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401326618"
    },
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/events/401326603"
    },
```

[[TOP]](#top)

### TEAM INJURIES API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/teams/12/injuries

```json
{
  "count": 63,
  "pageIndex": 1,
  "pageSize": 25,
  "pageCount": 3,
  "items": [
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/athletes/4408854/injuries/-1252999"
    },
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/athletes/3048898/injuries/499227"
    },
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/athletes/3055899/injuries/499204"
    },
```

[[TOP]](#top)

### TEAM LEADERS API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/teams/12/leaders

```json
{
  "id": "0",
  "name": "TOTAL",
  "abbreviation": "Any",
  "categories": [
    {
      "name": "passingLeader",
      "displayName": "Passing Leader",
      "shortDisplayName": "PASS",
      "abbreviation": "PYDS",
      "leaders": [
        {
          "displayValue": "360-549, 4052 YDS, 30 TD, 13 INT",
          "value": 4052,
```

[[TOP]](#top)

### TEAM ODDS-RECORDS API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/teams/12/odds-records

```json
{
  "count": 10,
  "pageIndex": 1,
  "pageSize": 25,
  "pageCount": 1,
  "items": [
    {
      "abbreviation": "ML",
      "displayName": "Money Line Overall Record",
      "shortDisplayName": "Money Line",
      "type": "moneyLineOverall",
      "stats": [
        {
          "displayName": "Wins",
          "abbreviation": "W",
```

[[TOP]](#top)

### TEAM PROJECTION API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/teams/12/projection

```json
{
  "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/teams/1/projection",
  "team": {
    "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/teams/1"
  },
  "chanceToWinThisWeek": 0.59114,
  "chanceToWinDivision": 0,
  "projectedWins": 7.085,
  "projectedLosses": 9.908
}
```

[[TOP]](#top)

### TEAM RECORD API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/teams/12/record

```json
{
  "count": 5,
  "pageIndex": 1,
  "pageSize": 25,
  "pageCount": 1,
  "items": [
    {
      "id": "0",
      "name": "All Splits",
      "abbreviation": "Any",
      "type": "total",
      "summary": "10-4",
      "displayValue": "10-4",
      "value": 0.7142857142857143,
```

[[TOP]](#top)

### TEAM ROSTER API

**URL**: https://site.api.espn.com/apis/site/v2/sports/football/nfl/teams/12/roster

```json
{
  "timestamp": "2021-12-21T12:39:06Z",
  "status": "success",
  "season": {
    "year": 2021,
    "type": 2,
    "name": "Regular Season"
  },
  "coach": [
    {
      "id": "17739",
      "firstName": "Arthur",
      "lastName": "Smith",
      "experience": 0
    }
```

[[TOP]](#top)

### TEAM SCHEDULE API

**URL**: https://site.api.espn.com/apis/site/v2/sports/football/nfl/teams/12/schedule

```json
{
  "timestamp": "2021-12-21T12:39:07Z",
  "status": "success",
  "season": {
    "year": 2021,
    "type": 2,
    "name": "Regular Season",
    "displayName": "2021",
    "half": 1
  },
  "team": {
    "id": "1",
    "abbreviation": "ATL",
    "location": "Atlanta",
    "name": "Falcons",
```

[[TOP]](#top)

### TEAM STATISTICS API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/teams/12/statistics

```json
{
  "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/teams/1/statistics/0",
  "season": {
    "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021"
  },
  "team": {
    "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/teams/1"
  },
  "splits": {
    "id": "0",
    "name": "All Splits",
    "abbreviation": "Any",
    "categories": [
      {
        "name": "general",
```

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/teams/12/statistics/0

```json
{
  "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/teams/12/statistics/0",
  "season": {
    "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021"
  },
  "team": {
    "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/teams/12"
  },
  "splits": {
    "id": "0",
    "name": "All Splits",
    "abbreviation": "Any",
    "categories": [
      {
        "name": "general",
```

[[TOP]](#top)

### SEASONTYPE GROUPS API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/groups

```json
{
  "count": 2,
  "pageIndex": 1,
  "pageSize": 25,
  "pageCount": 1,
  "items": [
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/groups/8"
    },
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/groups/7"
    }
  ]
}
```

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/groups/1

```json
{
  "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/groups/9",
  "uid": "s:20~l:28~g:9",
  "id": "9",
  "name": "National Football League",
  "abbreviation": "NFL",
  "shortName": "NFL",
  "season": {
    "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021"
  },
  "children": {
    "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/groups/9/children"
  },
  "standings": {
    "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/groups/9/standings"
  },
  "isConference": false,
  "slug": "national-football-league",
  "teams": {
    "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/groups/9/teams"
  }
}
```

[[TOP]](#top)

### SEASONTYPE LEADERS API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/leaders

```json
{
  "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/3/leaders",
  "id": "0",
  "name": "TOTAL",
  "abbreviation": "Any",
  "categories": [
    {
      "name": "passingYards",
      "displayName": "Passing Yards",
      "shortDisplayName": "PYDS",
      "abbreviation": "YDS",
      "leaders": [
        {
          "displayValue": "404",
          "value": 404,
          "rel": [
            "athlete"
          ],
          "athlete": {
            "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/athletes/3139477"
          },
          "team": {
            "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/teams/12"
          },
          "statistics": {
            "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/3/athletes/3139477/statistics/0"
          }
        },
```

[[TOP]](#top)

### SEASONTYPE WEEKS API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/weeks

```json
{
  "count": 18,
  "pageIndex": 1,
  "pageSize": 25,
  "pageCount": 1,
  "items": [
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/weeks/1"
    },
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/weeks/2"
    },
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/weeks/3"
    },
```

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/weeks/6

```json
{
  "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/weeks/6",
  "number": 6,
  "startDate": "2021-10-13T07:00Z",
  "endDate": "2021-10-20T06:59Z",
  "text": "Week 6",
  "teamsOnBye": [
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/teams/1"
    },
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/teams/18"
    },
    {
      "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/teams/20"
```

[[TOP]](#top)

### VENUES API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/venues/3493

```json
{
  "id": "3493",
  "fullName": "Caesars Superdome",
  "address": {
    "city": "New Orleans",
    "state": "LA",
    "zipCode": "70112"
  },
  "capacity": 73000,
  "grass": false,
  "indoor": true,
  "images": [
    {
      "href": "https://a.espncdn.com/i/venues/nfl/day/3493.jpg",
```

[[TOP]](#top)

### WEEKLY EVENTS API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/weeks/6/events

```json
{
  "$meta": {
    "parameters": {
      "week": [
        "6"
      ],
      "season": [
        "2021"
      ],
      "seasontypes": [
        "2"
      ]
    }
  },
  "count": 14,
```

[[TOP]](#top)

### WEEKLY QBR API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/weeks/6/qbr/10000

```json
{
  "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/weeks/6/qbr/10000",
  "count": 28,
  "pageIndex": 1,
  "pageSize": 25,
  "pageCount": 2,
  "items": [
    {
      "athlete": {
        "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/athletes/2330"
      },
      "team": {
        "$ref": "http://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/teams/27"
      },
      "event": {
```

[[TOP]](#top)

### WEEKLY TALENTPICKS API

**URL**: https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2021/types/2/weeks/6/talentpicks

```json
{
  "count": 154,
  "pageIndex": 1,
  "pageSize": 25,
  "pageCount": 7,
  "items": [
    {
      "pick": {
        "person": {
          "id": "1768",
          "firstName": "Damien",
          "lastName": "Woody",
          "displayName": "Damien Woody",
          "headshot": {
            "href": "https://a.espncdn.com/i/columnists/full/woody_damien.png",
```

</details>

--------------------------------------------------------------------------------
FILE: testing\shell_output.txt
--------------------------------------------------------------------------------
PS C:\Users\roman\Desktop\JMU\Class stuff\Year 3\Semester 1\CS 343\Projects\local repository\343f24final-ltrfantasy\testing>node apiTester.js > output.txt
Attempt 1/3 failed for https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2024/types/2/athletes/invalid_id/statistics: HTTP error! status: 404 for https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2024/types/2/athletes/invalid_id/statistics
Attempt 2/3 failed for https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2024/types/2/athletes/invalid_id/statistics: HTTP error! status: 404 for https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2024/types/2/athletes/invalid_id/statistics
Attempt 3/3 failed for https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2024/types/2/athletes/invalid_id/statistics: HTTP error! status: 404 for https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2024/types/2/athletes/invalid_id/statistics
Attempt 1/3 failed for https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2024/types/2/teams/999/statistics: HTTP error! status: 404 for https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2024/types/2/teams/999/statistics
Attempt 2/3 failed for https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2024/types/2/teams/999/statistics: HTTP error! status: 404 for https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2024/types/2/teams/999/statistics
Attempt 3/3 failed for https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2024/types/2/teams/999/statistics: HTTP error! status: 404 for https://sports.core.api.espn.com/v2/sports/football/leagues/nfl/seasons/2024/types/2/teams/999/statistics
Invalid PLAYER data structure received: {}
PS C:\Users\roman\Desktop\JMU\Class stuff\Year 3\Semester 1\CS 343\Projects\local repository\343f24final-ltrfantasy\testing